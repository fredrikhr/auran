//
// ListItemPropertyHandler.gs
//
//  Copyright (C) 2004-2005 Auran Developments Pty Ltd
//  All Rights Reserved.
//

include "HTMLPropertyHandler.gs"
include "common.gs"
include "World.gs"
include "common.gs"
include "HTMLBuffer.gs"
include "TrainzAssetSearch.gs"


//! A generic handler class that can be used to build handlers that initialize themselves from an Asset's string table.
//
// There are two main data members in this class: the host asset and the config prefix.  The host asset can be
// any Asset and is used to access a StringTable.  The config prefix will be prefixed to a property name when 
// accessing information from the string table.  Generally a string table item will take the following form:
//  - <m "&lt;config-prefix&gt;-&lt;property-name&gt;">
//
// Note that there is variation of this general convention for specific purposes.  This mainly happens in the
// various child classes and will be noted where applicable.
//
// Once a config handler has been created, its Init() method needs to be called, otherwise this handler is of
// little use.  Both the host asset and config prefix are set through the Init(Asset,string) method.
//
// For the ConfigAssetHandler class, the following two optional string table items are checked for:
//  - <m "&lt;config-prefix&gt;-html-prefix">
//  - <m "&lt;config-prefix&gt;-html-sufix">
//
// These two strings are simply HTML wrappers to apply to the properties page generated by 
// GetDescriptionHTML().  Although the minimal ConfigAssetHandler implementation of GetDescriptionHTML() uses
// these two string values if they exist, you should not call through to this method this method in your own
// child class GetDescriptionHTML().  Instead, use the <n m_htmlPrefix> and <n m_htmlSufix> string variables 
// yourself to build the properties page as desired.
//
// Note that both GetProperties() & SetProperties() allow for the host asset and config prefix to be 
// saved/loaded. However it should always be the case that these two important values are set through
// the Init() method.  If these members are already initialized by Init(), SetProperties() will not 
// overwrite the fresh values Init() has set.
//
// This class works on the basis that the user takes some care and in most cases, will assume that the host
// asset is initialized properly.  Checks are not done every living moment of this class, although there are
// some checks such as during initialization or the saving and loading of properties.
// 
// If your ConfigAssetHandler-derived child class is not quite working, check the %Trainz log file
// (<b>\Trainz\JetLog.txt</b>) for clues.
//
// Note:
//     ConfigAssetHandler and its associated child classes were mainly written as utility classes for use in
//     the TRS2006 session rules.  These classes are not part of the API or fully documented and are included
//     for your convenience.  Those who are interested can see all the class definitions and implementations
//     in the <b \Trainz\scripts\ListItemPropertyHandler.gs> file.  Also of interest is the 
//     \ref astSrcRule "source code" of the TRS2006 rules, many of which contain usage examples of the config
//     asset handler family of classes.
//
// See Also:
//     PropertyObject::SetPropertyHandler(), HTMLPropertyGroup::AddHandler(), AssetCheckListHandler,
//     ConfigAssetGroupHandler, CheckBoxHandler, CheckListPropertyHandler, EnumeratedAssetHandler,
//     EnumeratedGameObjectHandler, EnumeratedMultiPropertyHandler, EnumeratedPropertyHandler, 
//     GenericBoolHandler, GenericIntNumberHandler, GenericStringHandler, RadioButtonListHandler
//
class ConfigAssetHandler isclass HTMLPropertyHandler
{
  Asset       m_hostAsset;          // Host asset where the string-table to find.
  StringTable m_assetStrTable;      // String table of m_hostAsset.
  string      m_configPrefix = "";  // Config prefix string to use when accessing the string-table.  Not to be confused with the handler prefix.

  // Strings to be used to wrap around the HTML code.  Use is optional, but can be handy for things like
  // wrapping property HTML description in <font> tags for example.
  //
  // If you want to use these values, then you must use them directly in your own GetDescriptionHTML()
  // method - this class doesn't really have a working GetDescriptionHTML() implementation of any note.
  //
  string m_htmlPrefix = "";
  string m_htmlSufix  = "";


  //
  // ConfigAsset-specific method definitions
  //

  //! Initializes this config asset handler.
  //
  // When a config asset handler of any type is created, it must be initialized by calling this method before
  // anything else is done with the handler such as attaching it to a PropertyObject-derived class or 
  // <l HTMLPropertyGroup  group handler>.
  //
  // Param:  asset            Host Asset with StringTable for use by this handler to get configuration and 
  //                          text data.
  // Param:  newConfigPrefix  The string that will be prefixed on all string table elements this handler
  //                          accesses.  See the main class description above for details of what strings
  //                          this class may require.
  //
  // Note:
  //     There are various other Init() methods seen in the config asset handler class definitions but they
  //     are generally to be avoided as they are not fully tested.  If you do use them, make sure you read
  //     the implementation code and understand what is going on.
  //
  public void Init(Asset asset, string newConfigPrefix);

  public void Init(Asset asset, string newConfigPrefix, PropertyValue[] extraValues);
  void  InitBasics(Asset asset, string newConfigPrefix);

  public string      GetConfigPrefix(void) { return m_configPrefix; }   //!< Gets the config prefix of this config asset handler.
  public Asset       GetHostAsset(void)    { return m_hostAsset; }      //!< Gets the host Asset of this config asset handler.
  public StringTable GetStringTable(void)  { return m_assetStrTable; }  //!< Gets the StringTable of the host asset.


  //
  // Local method implementaions
  //

  //
  // Initialization method. This method must be called!
  //
  public void Init(Asset asset, string newConfigPrefix)
  {
    InitBasics(asset, newConfigPrefix);
  }

  //
  // Alternative initialization method. The extraValues paramater isn't used in this high-level class, rather
  // it is provided as a mechanism for the programmer to initialize their handler with their own custom values
  // through a common interface method.
  //
  public void Init(Asset asset, string newConfigPrefix, PropertyValue[] extraValues)
  {
    InitBasics(asset, newConfigPrefix);
  }


  void InitBasics(Asset asset, string newConfigPrefix)
  {
    if (!asset)
    {
      Interface.Log("# ConfigAssetHandler.InitBasics> ERROR: invalid asset provided!");
      return;
    }

    m_hostAsset = asset;
    m_assetStrTable = asset.GetStringTableCached();
    m_configPrefix = newConfigPrefix;

    if (!m_configPrefix.size())
      Interface.Log("# ConfigAssetHandler.Basics> WARNING: config prefix is empty!");

    // initialise these values once, doeesn't matter if no html prefix/sufix is provided as they will default
    // to blank strings
    m_htmlPrefix = m_assetStrTable.GetString(m_configPrefix + "-html-prefix");
    m_htmlSufix = m_assetStrTable.GetString(m_configPrefix + "-html-sufix");
  }


  //
  // Property handler methods
  //

  //
  // Dummy implementation that reminds us how this method isn't implemented, namely in a child class
  //
  public string GetDescriptionHTML(void)
  {
    Interface.Log("# ConfigAssetHandler.GetDescriptionHTML> WARNING: I am not implemented!!!");
    return m_htmlPrefix + "null" + m_htmlSufix;
  }

  //
  // This implementation will save the config prefix & host asset and should always be called when overridden
  // in a child class, so don't forget to call it in your own child class implementation!
  //
  public Soup GetProperties()
  {
    Soup soup = inherited();
    soup.SetNamedTag("ConfigAssetHandler.configPrefix", m_configPrefix);

    // don't want to try and get a KUID from a null asset :-/
    if (m_hostAsset)
      soup.SetNamedTag("ConfigAssetHandler.assetKUID", m_hostAsset.GetKUID());
    else
      Interface.Log("# ConfigAssetHandler.GetProperties:'" + m_configPrefix + "'> ERROR: invalid host asset/KUID");

    return soup;
  }

  //
  // This implementation will load the saved config prefix & host asset and should always be called when
  // overridden in a child class, so don't forget to call it in your own child class implementation!
  //
  public void SetProperties(Soup soup)
  {
    inherited(soup);

    // only try to load the config prefix from the soup if this handler doesn't already have one - this can prevent
    // older/missing soup config prefix from overriding the handler's own initialization
    if (!m_configPrefix.size())
      m_configPrefix = soup.GetNamedTag("ConfigAssetHandler.configPrefix");

    // only try this if we don't already have a valid asset/stringtable (we don't want Init()'s fresh settings
    // being overwritten)
    if (!m_assetStrTable)
    {
      KUID assetKUID = soup.GetNamedTagAsKUID("ConfigAssetHandler.assetKUID");
      if (!assetKUID)
      {
        Interface.Log("# ConfigAssetHandler.SetProperties:'" + m_configPrefix + "'> ERROR: invalid host asset/KUID");
        return;
      }
      m_hostAsset = World.FindAsset(assetKUID);
      m_assetStrTable = m_hostAsset.GetStringTableCached();
    }
  }

};


//! A group version of ConfigAssetHandler.
//
// This class is very similar to ConfigAssetHandler except that it allows for a group of sub-handlers.  The
// main reasons for this class' existence is to provide the HTMLPropertyGroup capabilities in a class that also
// has the features of ConfigAssetHandler.  As ConfigAssetHandler inherits directly from HTMLPropertyHandler,
// it isn't really suitable for being a group handler - hence the need for this class.
//
// A ConfigAssetGroupHandler can contain any property handler and isn't restricted to handlers from the config
// asset family of classes (i.e. anything derived from either ConfigAssetHandler or this class).  If however
// you are going to add a config asset derived handler to this group handler, it should be initialized before
// it is added.  Like HTMLPropertyGroup, this class assumes the sub-handlers provided have already been
// initialized and are ready for use.
//
// See Also:
//     ConfigAssetHandler, HTMLPropertyGroup, CheckListGroupHandler, GenericListHandler, 
//     RadioButtonGroupHandler
//
class ConfigAssetGroupHandler isclass HTMLPropertyGroup
{
  Asset       m_hostAsset;
  StringTable m_assetStrTable;
  string      m_configPrefix = "";

  // String to be used to wrap around the HTML code.  Use is optional, but can be handy for things like
  // wrapping property HTML description in <font> tags for example.
  //
  // If you want to use these values, then you must use them directly in your own GetDescriptionHTML()
  // method - this class doesn't really have a working GetDescriptionHTML() implementation of any note.
  string m_htmlPrefix = "";
  string m_htmlSufix  = "";


  //
  // ConfigGroupAssetHandler local method definitions
  //

  //! Initializes this config asset group handler.
  //
  // When a config group asset handler of any type is created, it must be initialized by calling this method
  // before anything else is done with the handler such as attaching it to a PropertyObject-derived class or 
  // <l HTMLPropertyGroup  group handler>.
  //
  // Note that calling this method does not do anything to any sub-handlers.  It is recommended that Init() is
  // called on the ConfigAssetGroupHandler before any sub-handlers are added.
  //
  // Param:  asset            Host Asset with StringTable for use by this handler to get configuration and 
  //                          text data.
  // Param:  newConfigPrefix  The string that will be prefixed on all string table elements this handler
  //                          accesses.  See the main class description above for details of what strings
  //                          this class may require.
  //
  // Note:
  //     There are various other Init() methods seen in the config asset handler class definitions but they
  //     are generally to be avoided as they are not fully tested.  If you do use them, make sure you read
  //     the implementation code and understand what is going on.
  //

  public void Init(Asset asset, string newConfigPrefix);  

  public void Init(Asset asset, string newConfigPrefix, PropertyValue[] extraValues);
  void InitBasics(Asset asset, string newConfigPrefix);

  public string      GetConfigPrefix()    { return m_configPrefix; }   //!< Gets the config prefix of this config group asset handler.
  public Asset       GetHostAsset()       { return m_hostAsset; }      //!< Gets the host Asset of this config group asset handler.
  public StringTable GetStringTable(void) { return m_assetStrTable; }  //!< Gets the StringTable of the host Asset.


  //
  // Local method implementaions
  //

  public void Init(Asset asset, string newConfigPrefix)
  {
    InitBasics(asset, newConfigPrefix);
  }

  //
  // Alternative initialization method. The extraValues paramater isn't used in this high-level class, rather
  // it is provided as a mechanism for the programmer to initialize their handler with their own custom values
  // through a common interface method.
  //
  public void Init(Asset asset, string newConfigPrefix, PropertyValue[] extraValues)
  {
    InitBasics(asset, newConfigPrefix);
  }

  //
  //
  //
  void InitBasics(Asset asset, string newConfigPrefix)
  {
    if (!asset)
    {
      Interface.Log("# ConfigAssetHandler.InitBasics> ERROR: invalid asset provided!");
      return;
    }

    m_hostAsset = asset;
    m_assetStrTable = asset.GetStringTableCached();
    m_configPrefix = newConfigPrefix;

    if (!m_configPrefix.size())
      Interface.Log("# ConfigAssetHandler.Basics> WARNING: config prefix is empty!");

    // initialise these values once, doeesn't matter if no html prefix/sufix is provided as they will default
    // to blank strings
    m_htmlPrefix = m_assetStrTable.GetString(m_configPrefix + "-html-prefix");
    m_htmlSufix = m_assetStrTable.GetString(m_configPrefix + "-html-sufix");
  }


  //
  // Property handler methods
  //

  //
  // Basic implementation that ....
  //
  public string GetDescriptionHTML(void)
  {
    int i;
    HTMLBuffer html = HTMLBufferStatic.Construct();

    html.Print(m_htmlPrefix);
    for (i = 0; i < handlers.size(); i++)
      html.Print(handlers[i].GetDescriptionHTML());
    html.Print(m_htmlSufix);

    return html.AsString();
  }

  //
  // This implementation will save the config prefix & host asset and should always be called when
  // overridden in a child class.
  //
  // If the m_groupHandlerSaving flag is set, then HTMLPropertyGroup.GetProperties() will be used to get
  // the properties of any sub-handlers in this group.  If disabled, it is up to you to save sub-handlers
  // in your own overridden version of this method.
  //
  public Soup GetProperties()
  {
    Soup soup = inherited(); // don't use group handler child class handling
//    Soup soup = Constructors.NewSoup();

    soup.SetNamedTag("ConfigAssetGroupHandler.configPrefix", m_configPrefix);

    // don't want to try and extract a KUID from a null asset :-/
    if (m_hostAsset)
      soup.SetNamedTag("ConfigAssetGroupHandler.assetKUID", m_hostAsset.GetKUID());
    else
      Interface.Log("# ConfigAssetGroupHandler.GetProperties:'" + m_configPrefix + "'> ERROR: invalid host asset/KUID");

    return soup;
  }

  //
  // This implementation will load the saved config prefix & host asset and should always be called when
  // overridden in a child class.
  //
  // If the m_groupHandlerSaving flag is set, then HTMLPropertyGroup.SetProperties() will be used to 
  // initialize the child handlers from the soup.  If you want your sub-handlers initialized this way, then
  // make sure you create the handler objects before calling through to this method!
  //
  public void SetProperties(Soup soup)
  {
    inherited(soup); // we don't use group handler for setting properties - that is left to user

    // only try to load the config prefix from the soup if this handler doesn't already have one - this can
    // prevent older/missing soup config prefix from overriding the handler's own initialization
    if (!m_configPrefix.size())
      m_configPrefix = soup.GetNamedTag("ConfigAssetGroupHandler.configPrefix");

    // only try this if we don't already have a valid asset/stringtable (we don't want Init()'s fresh settings
    // being overwritten)
    if (!m_assetStrTable)
    {
      KUID assetKUID = soup.GetNamedTagAsKUID("ConfigAssetGroupHandler.assetKUID");
      if (!assetKUID)
      {
        Interface.Log("# ConfigAssetGroupHandler.SetProperties:'" + m_configPrefix + "'> ERROR: invalid host asset/KUID");
        return;
      }
      m_hostAsset = World.FindAsset(assetKUID);
      m_assetStrTable = m_hostAsset.GetStringTableCached();
    }
  }

  public PropertyValue GetPropertyAttribute(string propertyID, string attribute)
  {
    return inherited(propertyID, attribute);
  }

  public void SetPropertyAttribute(string propertyID, string attribute, PropertyValue value)
  {
    inherited(propertyID, attribute, value);
  }

};


//! A config asset handler that manages multiple string properties.
//
// This handler manages a list of string property values.  Although the amount of strings this handler can 
// have is customizable, once created the <l GetStringCount()  amount of strings> is set and cannot be 
// changed unless the object is re-initialized.
//
// This class varies from other config asset handler classes as it is not initialized through the Init() 
// method.  Instead, you must call Init(Asset,string,int) method where you specify how many strings you want
// the handler to manage.
//
// This config handler has a property for each string it contains.  The property name for a string takes the
// form of <m "string/$N"> where $N is the index to the desired string.
//
// The string table items supported by this config asset handler are:
//
// {[ String Name                       | Description                            ]
//  [ "<config-prefix>-display-X"       | Template string to display various strings of this handler in the 
//                                        properties window where 'X' is the total amount of strings.  There must
//                                        be string parameters from $0 through to $X for each string this handler
//                                        has.  These parameters can be placed within the string in any order and
//                                        surrounding by other text as desired.  ]
//  [ "<config-prefix>-blank-$N"        | Default value used to represent a blank, un-initialized $Nth [0-X]
//                                        string.  Having such a default place holder for each string in the 
//                                        handler is essential, otherwise a property link to click on and change
//                                        the string value cannot be provided.   ]
//  [  |  ]
//  [ "<config-prefix>-name-string/$N"  | Name to describe the $Nth string [0-X] in a text entry box when 
//                                        setting it.  ]
//  [ "<config-prefix>-desc-string/$N"  | Text description used as a tooltip to describe what the $Nth string
//                                        property represents in the text entry box.  Optional but advised.  ]
//  [  |  ]
//  [ "<config-prefix>-html-prefix"     | HTML code inserted at the start of the properties page.  ]
//  [ "<config-prefix>-html-sufix"      | HTML code inserted at the end of the properties page.    ]}
//
// For this config asset handler to work, it is essential that the first string table item listed above is 
// included along with a <m "<config-prefix>-blank-$N"> item for each string property the handler is to have.
//
// Having a <m "<config-prefix>-name-string/$N"> and <m "<config-prefix>-desc-string/$N"> values for each
// string property is optional but strongly recommended if you want your properties window to be user 
// friendly.
//
// Both the <m "<config-prefix>-html-prefix"> and <m "<config-prefix>-html-sufix"> string items are optional, 
// although if present the GetDescriptionHTML() implementation of this class will use them to wrap the 
// generated HTML code up in.
//
// Note:
//     GenericStringHandler is not very tolerant of bad string table configurations.  They must be match the
//     specifications above and correspond to the amount of string properties you specify when initializing 
//     the GenericStringHandler object with its Init(Asset,string,int) method.
//
// As an example, here are some string table items from the <l astSrcRuleWaitHTMLPages  Wait for HTML Pages>
// rule.  This particular configuration is used for a GenericStringHandler that has one string property
// so a HTML page name can be used in the rule's configuration properties.
//
// {[ String Name                     | Contents                      ]
//  [ "wait-page-open-display-1"      | "open the page named $0"      ]
//  [ "wait-page-open-blank-0"        | "index"                       ]
//  [  |  ]
//  [ "wait-page-open-name-string/0"  | "HTML page name"              ]
//  [ "wait-page-open-desc-string/0"  | "Name of HTML page without the .html extension"  ]
//  [  |  ]
//  [ "wait-page-open-html-prefix"    | "&lt;font color=#000000&gt;"  ]
//  [ "wait-page-open-html-sufix"     | "&lt;/font&gt;"               ]}
//
// This handler is also used by <l astSrcRuleSetHTMLPages  Set HTML Pages> rule.
//
// See Also:
//     ConfigAssetHandler, CheckBoxHandler, AssetCheckListHandler, CheckListPropertyHandler, 
//     EnumeratedAssetHandler, GenericBoolHandler, GenericIntNumberHandler
//
class GenericStringHandler isclass ConfigAssetHandler
{
  string[] m_stringValues = new string[0];
  string   m_displayString = "";
  int      m_stringCount = 0;


  //
  // Public methods
  //

  // work-around...crude but it's what we need :(
  public void Init(Asset asset, string newConfigPrefix) { inherited(asset, newConfigPrefix); }
  
  //! Variation of Init() with an extra parameter to specify the amount of strings this handler is to have.
  //
  // This variation of Init() <bi MUST> used for a GenericStringHandler as the handler needs to know how many
  // property strings it is going to have on initialization.  This also applies to any child classes.
  //
  // Param:  asset            Host Asset with StringTable for use by this handler to get configuration and 
  //                          text data.
  // Param:  newConfigPrefix  The string that will be prefixed on all string table elements this handler
  //                          accesses.  See the main class description above for details of what strings
  //                          this class may require.
  // Param:  newStringCount   Amount of string properties this handler will have.
  //
  public void Init(Asset asset, string newConfigPrefix, int newStringCount);

  //! Gets the amount of string properties this handler has.
  //
  // Note:
  //     The amount of strings is set on initialization and can't be changed unless you re-initialize the
  //     GenericStringHandler object.
  //
  // Returns:
  //     Returns the amount of string properties this handler has.
  //
  public int GetStringCount(void) { return m_stringCount; }

  //! Gets the contents of the specified string property by index.
  //
  // Param:  valueIndex  Index of the string property to get the current 
  //
  // Returns:
  //     Returns the contents of the string property specified by <i valueIndex>.  If the string isn't already
  //     set to something, a blank string of "" is returned.  If <i valueIndex> doesn't refer to a valid 
  //     string property 
  //
  public string GetStringValue(int valueIndex);

  //! Gets the display value of the specified string by index.
  //
  // This method is intended to be used for interface displays where a more presentable form of the string 
  // property is required.
  //
  // Param:  valueIndex  Index to the string property.
  //
  // Returns:
  //     Returns the contents of the string property specified by <i valueIndex>.  If the string isn't 
  //     already set to something, the default blank value for that string as specified in the
  //     <m "<config-prefix>-blank-&lt;index&gt;"> string table entry of the host asset will be returned.
  //     If this default blank value can't be found or <i valueIndex> refers to an invalid string, "null" 
  //     (as a 4 character string, not a <l gscLangKeyNull null> reference) is returned.
  //
  public string GetStringDisplayValue(int valueIndex);


  //
  // Method implementations
  //

  //
  // Initilization method that requires the amount of stringed properties this handler has to be specified
  // in the newStringCount argument.
  //
  public void Init(Asset asset, string newConfigPrefix, int newStringCount)
  {
    Init(asset, newConfigPrefix);

    m_stringCount = newStringCount;
    m_displayString = m_assetStrTable.GetString(m_configPrefix + "-display-" + (string)m_stringCount);
    if (!m_displayString.size())
      Interface.Log("# GenericStringHandler.Init> '" + m_configPrefix + "' - ERROR: Unable to find string table entry!");


    if (!m_stringValues.size())
    {
      // create empty strings list (so no script crash/exception if we try to display it etc.)
      m_stringValues = new string[m_stringCount];
      int i;
      for (i = 0; i < m_stringCount; i++)
        m_stringValues[i] = "";
    }

  }

  //
  // Gets the value of the specified string by index.
  //
  public string GetStringValue(int valueIndex)
  {
    if ((valueIndex < m_stringCount)  and  (valueIndex >= 0))
      return m_stringValues[valueIndex];

    return "null";
  }

  //
  // Gets the display value of the string by index.
  //
  public string GetStringDisplayValue(int valueIndex)
  {
    string obtainedString = GetStringValue(valueIndex);

    // use config asset's blank substitution value for the string if empty
    if (!obtainedString.size())
    {
      obtainedString = m_assetStrTable.GetString(m_configPrefix + "-blank-" + valueIndex);
      if (!obtainedString.size())
        obtainedString = "null";
    }

    return obtainedString;
  }


  //
  // Property handler methods
  //

  public string GetDescriptionHTML(void)
  {
    int i;
    for (i = 0; i < m_stringCount; i++)
      m_assetStrTable.SetParam(i, HREF("string/" + (string)i) + GetStringDisplayValue(i) + "</a>");

    // parameters are all set now, so grab the string (+ reset params)
    m_displayString = m_assetStrTable.GetString(m_configPrefix + "-display-" + (string)m_stringCount);
    m_assetStrTable.ClearParams();

    return m_htmlPrefix + m_displayString + m_htmlSufix;
  }

  public string GetPropertyType(string propertyID)
  {
    string property = PropStripPrefix(propertyID, "");
    if (TrainUtil.GetUpTo(property, "/") == "string")
      return "string";

    return inherited(propertyID);
  }

  public string GetPropertyValue(string propertyID)
  {
    string property = PropStripPrefix(propertyID, "");
    if (TrainUtil.GetUpTo(property, "/") == "string")
    {
      int propertyNumber = Str.ToInt(TrainUtil.GetAfter(property, "/"));
      if (m_stringValues.size() > propertyNumber)
        return m_stringValues[propertyNumber];
    }

    return inherited(propertyID);
  }

  public void SetPropertyValue(string propertyID, PropertyValue value)
  {
    string property = PropStripPrefix(propertyID, "");
    if (TrainUtil.GetUpTo(property, "/") == "string")
    {
      int propertyNumber = Str.ToInt(TrainUtil.GetAfter(property, "/"));
      if (m_stringValues.size() > propertyNumber)
        m_stringValues[propertyNumber] = value.AsString();
    }
    else
      inherited(propertyID, value);
  }

  public string GetPropertyName(string propertyID)
  {
    string property = PropStripPrefix(propertyID, "");
    if (TrainUtil.GetUpTo(property, "/") == "string")
      return m_assetStrTable.GetString(m_configPrefix + "-name-" + property);
    
    return inherited(propertyID);  
  }

  public string GetPropertyDescription(string propertyID)
  {
    string property = PropStripPrefix(propertyID, "");
    if (TrainUtil.GetUpTo(property, "/") == "string")
      return m_assetStrTable.GetString(m_configPrefix + "-desc-" + property);
    
    return inherited(propertyID);  
  }


  public void SetProperties(Soup soup)
  {
    inherited(soup);

    if (!m_displayString.size())
      m_displayString = soup.GetNamedTag("GenericStringHandler.displayString"); 

    m_stringCount = soup.GetNamedTagAsInt("GenericStringHandler.stringCount");

    Soup stringListSoup = soup.GetNamedSoup("GenericStringHandler.stringList");
    m_stringValues = new string[0];
    int i;
    for (i = 0; i < stringListSoup.CountTags(); i++)
      m_stringValues[i] = stringListSoup.GetNamedTag((string)i);
  }

  public Soup GetProperties(void)
  {
    Soup soup = inherited();

    soup.SetNamedTag("GenericStringHandler.displayString", m_displayString);
    soup.SetNamedTag("GenericStringHandler.stringCount", m_stringCount);

    Soup stringListSoup = Constructors.NewSoup();
    int i;
    for (i = 0; i < m_stringCount; i++)
      stringListSoup.SetNamedTag((string)i, m_stringValues[i]);

    soup.SetNamedSoup("GenericStringHandler.stringList", stringListSoup);
    return soup;
  }

};


//! Container class for an integer property.
//
// This class was written to be used with the GenericIntNumberHandler class to store an integer value along
// with the accompanying properties of a minimum and maximum value plus increments level.
//
// See Also:
//     GenericIntNumberHandler
//
class NumberValueInt
{
  public int m_intValue = 0;  // actual value
  public int m_intMinValue = 0, m_intMaxValue = 1000, m_intIncrements = 1; // dictate range/scope of the value
};


//! A config asset handler that manages multiple integer properties.
//
// This handler was initially written for a TRS2006 rule but the rule feature planned was scrapped, and rapidly
// fixed up much later. Hence this class may not be properly implemented or fully functional.
// Using this class <bi IS NOT> recommended.
//
// See Also:
//     NumberValueInt, GenericStringHandler
//
class GenericIntNumberHandler isclass ConfigAssetHandler
{
  NumberValueInt[] m_intValues = new NumberValueInt[0];
  string m_displayString = "";


  //
  // Public method definitions
  //

  // work-around...crude but it's what we need :(
  public void Init(Asset asset, string newConfigPrefix) { inherited(asset, newConfigPrefix); }

  public void Init(Asset asset, string newConfigPrefix, int newIntCount);

  public int GetIntCount(void) { return m_intValues.size(); }
  public int GetIntValue(int valueIndex);


  //
  // Local method implementations
  //

  //
  // Initilization method that requires the amount of stringed properties this handler has to be specified 
  // in the newNumberCount argument.
  //
  public void Init(Asset asset, string newConfigPrefix, int newIntCount)
  {
    Init(asset, newConfigPrefix);

    m_displayString = m_assetStrTable.GetString(m_configPrefix + "-display-" + (string)newIntCount);
    if (m_displayString.size() <= 0)
      Interface.Log("# GenericIntNumberHandler.Init> ERROR: Unable to find string table entry!");
      
    // create empty integer list (so no script crash/exception if we try to display it etc.)
    int i;
    for (i = 0; i < newIntCount; i++)
    {
      m_intValues[i] = new NumberValueInt();
    }
  }

  public int GetIntValue(int valueIndex)
  {
    if ((valueIndex < m_intValues.size())  and  (valueIndex >= 0))
      return m_intValues[valueIndex].m_intValue;

    return 0;
  }

  // For allowing default values
  public void PresetIntValue(int valueIndex, int value, int minValue, int maxValue, int increments)
  {
    if ((valueIndex < m_intValues.size())  and  (valueIndex >= 0))
    {
      m_intValues[valueIndex].m_intValue = value;
      m_intValues[valueIndex].m_intMinValue = minValue;
      m_intValues[valueIndex].m_intMaxValue = maxValue;
      m_intValues[valueIndex].m_intIncrements = increments;
    }
  }

  //
  // Property handler methods
  //
  
  public string GetDescriptionHTML(void)
  {
    int i;
    for (i = 0; i < m_intValues.size(); i++)
      m_assetStrTable.SetParam(i, HREF("value/" + (string)i) + m_intValues[i].m_intValue + "</a>");

    // parameters are all set now, so grab the string (+ reset params)
    m_displayString = m_assetStrTable.GetString(m_configPrefix + "-display-" + (string)m_intValues.size());
    m_assetStrTable.ClearParams();

    return m_htmlPrefix + m_displayString + m_htmlSufix;
  }

  public string GetPropertyType(string propertyID)
  {
    string property = PropStripPrefix(propertyID, "");
    if (TrainUtil.GetUpTo(property, "/") == "value")
    {
      int i = Str.ToInt(TrainUtil.GetAfter(property, "/"));
      string retval = "int," + m_intValues[i].m_intMinValue + "," + m_intValues[i].m_intMaxValue + "," + m_intValues[i].m_intIncrements;
      return retval;
    }
    
    return inherited(propertyID);
  }

  public string GetPropertyValue(string propertyID)
  {
    string property = PropStripPrefix(propertyID, "");
    if (TrainUtil.GetUpTo(property, "/") == "value")
    {
      int propertyNumber = Str.ToInt(TrainUtil.GetAfter(property, "/"));
      if (m_intValues.size() > propertyNumber)
        return (string)m_intValues[propertyNumber].m_intValue;
    }

    return inherited(propertyID);
  }

  // dw: todo
  // jrm 2012-04-26 -- Filled this function in. Hopefully as DW intended ;-)
  public string GetPropertyName(string propertyID)
  {
    string property = PropStripPrefix(propertyID, "");
    if (TrainUtil.GetUpTo(property, "/") == "value")
      return m_assetStrTable.GetString(m_configPrefix + "-name-" + property);

    return inherited(propertyID);  
  }

  // dw: todo
  // jrm 2012-04-26 -- Filled this function in. Hopefully as DW intended ;-)
  public string GetPropertyDescription(string propertyID)
  {
    string property = PropStripPrefix(propertyID, "");
    if (TrainUtil.GetUpTo(property, "/") == "value")
      return m_assetStrTable.GetString(m_configPrefix + "-desc-" + property);

    return inherited(propertyID);  
  }

  public void SetPropertyValue(string propertyID, PropertyValue value)
  {
    string property = PropStripPrefix(propertyID, "");
    if (TrainUtil.GetUpTo(property, "/") == "value")
    {
      int propertyNumber = Str.ToInt(TrainUtil.GetAfter(property, "/"));
      if ((propertyNumber >= 0)  and  (propertyNumber < m_intValues.size()))
      {
        if (!m_intValues[propertyNumber])
        {
          m_intValues[propertyNumber] = new NumberValueInt();
        }
        m_intValues[propertyNumber].m_intValue = value.AsInt();
      }
    }
    else
      inherited(propertyID, value);
  }

  // dw: todo
  // jrm 2012-04-18 -- Filled this function in. Hopefully as DW intended ;-)
  public void SetProperties(Soup soup)
  {
    inherited(soup);

    if (!m_displayString.size())
      m_displayString = soup.GetNamedTag("GenericIntNumberHandler.displayString"); 

    int numValues = soup.GetNamedTagAsInt("GenericIntNumberHandler.intNumberCount");
    m_intValues = new NumberValueInt[0];
    
    int i;
    for (i = 0; i < numValues; ++i)
    {
      NumberValueInt thisNumber = new NumberValueInt();
      Soup subSoup = soup.GetNamedSoup("NumberValueInt-" + i);
      
      thisNumber.m_intValue = subSoup.GetNamedTagAsInt("intValue");
      thisNumber.m_intMinValue = subSoup.GetNamedTagAsInt("intMinValue");
      thisNumber.m_intMaxValue = subSoup.GetNamedTagAsInt("intMaxValue");
      thisNumber.m_intIncrements = subSoup.GetNamedTagAsInt("intIncrements");
      
      m_intValues[i] = thisNumber;
    }
  }


  // dw: todo
  // jrm 2012-04-18 -- Filled this function in. Hopefully as DW intended ;-)
  public Soup GetProperties()
  {
    Soup soup = inherited();

    soup.SetNamedTag("GenericIntNumberHandler.displayString", m_displayString); 

    soup.SetNamedTag("GenericIntNumberHandler.intNumberCount", m_intValues.size());

    int i;
    for (i = 0; i < m_intValues.size(); ++i)
    {
      Soup subSoup = Constructors.NewSoup();
      
      subSoup.SetNamedTag("NumberValueInt.intValue", m_intValues[i].m_intValue); 
      subSoup.SetNamedTag("NumberValueInt.intMinValue", m_intValues[i].m_intMinValue); 
      subSoup.SetNamedTag("NumberValueInt.intMaxValue", m_intValues[i].m_intMaxValue); 
      subSoup.SetNamedTag("NumberValueInt.intIncrements", m_intValues[i].m_intIncrements); 
      
      soup.SetNamedSoup("NumberValueInt-" + i, subSoup);
    }

    return soup;
  }

};


//! A generic Boolean property handler that can be configured from a host asset's string table.
//
// This class is a handler for a single Boolean value and provides a properties interface that alternates 
// between two different text strings when a link within the string is clicked.  The only property in this
// handler is the <n "boolValue"> property.
//
// The string table items supported by this handler are:
//
// {[ String Name                            | Description                                    ]
//  [ "<config-prefix>-html-property-true"   | HTML string for when this handler is true.     ]
//  [ "<config-prefix>-html-property-false"  | HTML string for when this handler is false.    ]
//  [  |  ]
//  [ "<config-prefix>-html-bool-true"       | Descriptive text of bool property when true.   ]
//  [ "<config-prefix>-html-bool-false"      | Descriptive text of bool property when false.  ]
//  [  |  ]
//  [ "<config-prefix>-html-prefix"          | HTML code inserted at the start of the properties page.  ]
//  [ "<config-prefix>-html-sufix"           | HTML code inserted at the end of the properties page.    ]}
//
// For this handler to work, it is essential that the first two string table items listed above are included
// and that both of have two string parameters ($0 and $1).  The first ($0) will be where the link to change
// the Boolean value begins and will be of the form <m "&lt;a&nbsp;href=live://property/prefix/boolValue&gt;">
// while the second parameter is where the closing <m "&lt;/a&gt;"> tag is inserted.  What text is used in and
// around this parameters is entirely up to the author of the asset and there are no real restrictions.
//
// Note:
//     <bi DO NOT> place these two string parameters out of order (i.e. putting $1 before $0) as it will 
//     cause messy and corrupted links to be generated in the properties window.
//
// The optional <m "<config-prefix>-html-bool-true"> and <m "<config-prefix>-html-bool-false"> strings are 
// used as descriptive text for the current state of the bool property.  They are meant to be free of HTML 
// formatting tags making the text suitable for purposes like logging.  You only need to provide these
// strings if you are using the GetBoolDisplayValue() method.
//
// Both the <m "<config-prefix>-html-prefix"> and <m "<config-prefix>-html-sufix"> string items are optional,
// although if present the GetDescriptionHTML() implementation of this class will use them to wrap the 
// generated HTML code up in.
//
// For example here are the string table items from the <l astSrcRuleWaitDriverOnOff  Wait for Driver On/Off Train> 
// rule where the config prefix is <m "wait-driver-onoff">:
//
// {[ String Name                              | Contents  ]
//  [ "wait-driver-onoff-html-property-true"   | "Wait for a driver character to get $0on$1 a train that matches the following criteria:"   ]
//  [ "wait-driver-onoff-html-property-false"  | "Wait for a driver character to get $0off$1 a train that matches the following criteria:"  ]
//  [  |  ]
//  [ "wait-driver-onoff-html-bool-true"       | "on"      ]
//  [ "wait-driver-onoff-html-bool-false"      | "off"     ]
//  [  |  ]
//  [ "wait-driver-onoff-html-prefix"          | "&lt;table cellspacing=0 cellpadding=0&gt;&lt;tr&gt;&lt;td width=4&gt;&lt;/td&gt;&lt;td&gt;&lt;font color=#000000&gt;"  ]
//  [ "wait-driver-onoff-html-sufix"           | "&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;"  ]}
//
// The GenericBoolHandler class is also used by the following rules:
//  - <l astSrcRuleDisablIconNotif     Disabled HUD Icon Notification>
//  - <l astSrcRuleDrivMainMenu        Driver Main Menu Options>
//  - <l astSrcRuleEnaDisDrivCmds      Enable/Disable Driver Commands>
//  - <l astSrcRuleEnaDisHUDIcons      Enable/Disable HUD Icons>
//  - <l astSrcRuleMultJuncCheck       Multiple Junction Alignment Check>
//  - <l astSrcRuleSetCoupMasks        Set Coupler Masks>
//  - <l astSrcRuleSetHTMLPages        Set HTML Pages>
//  - <l astSrcRuleSetJuncs            Set Junctions>
//  - <l astSrcRuleShowHideMinimap     Show/Hide Minimap>
//  - <l astSrcRuleWaitMinimap         Wait on Minimap Screen/Main Screen>
//  - <l astSrcRuleWaitTrainStopStart  Wait on Train Stop/Start>
//  - <l astSrcRuleWaitWaybill         Wait on Waybill Screen/Main Screen>
//
// See Also:
//     ConfigAssetHandler, CheckBoxHandler, AssetCheckListHandler, CheckListPropertyHandler, 
//     EnumeratedAssetHandler, GenericStringHandler
//
class GenericBoolHandler isclass ConfigAssetHandler 
{
  bool   m_boolValue;
//  string m_boolLinkTooltip = "";


  //
  // Method definitions
  //

  //! Gets the bool value this handler manages.
  //
  // Returns:
  //     Returns the bool value this handler manages.
  //
  public bool GetBoolValue(void) { return m_boolValue; }

  //! Sets the value of the bool this handler manages.
  //
  // Param:  newBoolValue  New setting for this handler's bool value.
  //
  public void SetBoolValue(bool newBoolValue) { m_boolValue = newBoolValue; }

  //! Gets the descriptive display value for the bool property based on its current state.
  //
  // Returns:
  //     This method returns either the contents of the <m "<config-prefix>-html-bool-true"> or
  //     <m "<config-prefix>-html-bool-false"> string table items depending on the current state
  //     of the bool property.  If the string item can't be found, an empty string is returned.
  //
  public string GetBoolDisplayValue(void);


  // crude but necessary work-around :-/
  public void Init(Asset asset, string newConfigPrefix)
  { 
    inherited(asset, newConfigPrefix); 

    // if this ends up as being empty, than no big deal, there will just be no tooltip
    //m_boolLinkTooltip = m_assetStrTable.GetString(m_configPrefix + "-html-bool-tooltip");
  }

  // dw: I would generally not use this method, confusion/potential issues with derived classes
  public void Init(Asset asset, string newConfigPrefix, bool newBoolValue)
  {
    Init(asset, newConfigPrefix);
    m_boolValue = newBoolValue;
  }


  //
  // Gets name value for this bool property - not always suitable (a check box for example)
  //
  public string GetBoolDisplayValue(void)
  {
    return m_assetStrTable.GetString(m_configPrefix + "-html-bool-" + (string)m_boolValue);
  }


  //
  // Properties methods
  //

  //
  // Gets HTML page describing this object
  //
  public string GetDescriptionHTML(void)
  {
    string boolLink = "<a href='" + Link("boolValue") + "'>";
    string htmlPage = m_assetStrTable.GetString2(m_configPrefix + "-html-property-" + (string)m_boolValue, 
                                                 boolLink, "</a>");
    return m_htmlPrefix + htmlPage + m_htmlSufix;
  }

  //
  // Gets type for named property.
  //
  public string GetPropertyType(string propertyID)
  {
    if (PropStripPrefix(propertyID, "") == "boolValue")
      return "link";

    return inherited(propertyID);
  }

  //
  // Sets value of named property.
  //
  public void SetPropertyValue(string propertyID, PropertyValue value)
  {
    if (PropStripPrefix(propertyID, "") == "boolValue")
      m_boolValue = !m_boolValue;
    else
      inherited(propertyID, value);
  }

  //
  // Return properties of this object in a soup
  //
  public Soup GetProperties()
  {
    Soup soup = inherited();
    soup.SetNamedTag("GenericBoolHandler.boolValue", m_boolValue);
    return soup;
  }

  //
  // Initialize this object from the given properties soup
  //
  public void SetProperties(Soup soup)
  {
    inherited(soup);
    m_boolValue = soup.GetNamedTagAsBool("GenericBoolHandler.boolValue", m_boolValue);
  }


  public void SetPropertyAttribute(string propertyID, string attribute, PropertyValue value)
  {
    if (propertyID != GetPrefix())
    {
      inherited(propertyID, attribute, value);
      return;
    }

    if (attribute == "value")
      m_boolValue = value.AsBool();
    else
      inherited(propertyID, attribute, value);
  }

  public PropertyValue GetPropertyAttribute(string propertyID, string attribute)
  {
    if (propertyID != GetPrefix())
      return inherited(propertyID, attribute);

    PropertyValue ret = new PropertyValue();
    
    if (attribute == "value")
      ret.Set(m_boolValue);
    else
      return inherited(propertyID, attribute);

    return ret;
  }

};


//! Variation of GenericBoolHandler that is an on/off checkbox.
// 
// This handler manages a Boolean value in exactly the same way as its parent GenericBoolHandler does with
// the only difference being that a checkbox is used in the properties window.
//
// This class does not require the true/false string table items its parent does. Instead, all you need is a
// descriptive string to display along side the checkbox.  The checkbox image itself is handled by the class
// and is not something that needs to be provided.
//
// The string table items supported by this handler are:
//
// {[ String Name                      | Description                              ]
//  [ "<config-prefix>-html-checkbox"  | Text to display alongside the checkbox.  ]
//  [  |  ]
//  [ "<config-prefix>-html-prefix"    | HTML code inserted at the start of the properties page.  ]
//  [ "<config-prefix>-html-sufix"     | HTML code inserted at the end of the properties page.    ]}
//
// As with GenericBoolHandler, the both the <m "<config-prefix>-html-prefix"> and <m "<config-prefix>-html-sufix">
// string items are optional, although if present the GetDescriptionHTML() implementation of this class will
// use them to wrap the generated HTML code up in.
//
// The CheckBoxHandler class is used by the following rules:
//  - <l astSrcRuleConstChk            Consist Check>
//  - <l astSrcRuleVehicPhys           Vehicle Physics>
//  - <l astSrcRuleDisablIconNotif     Disabled HUD Icon Notification>
//  - <l astSrcRuleDrivCmdChk          Driver Command Check>
//  - <l astSrcRuleMultJuncCheck       Multiple Junction Alignment Check>
//  - <l astSrcRuleWaitCamera          Wait for Camera View Mode>
//  - <l astSrcRuleWaitHUDIconClick    Wait for Click on HUD Icon>
//  - <l astSrcRuleWaitDerail          Wait for Derailment>
//  - <l astSrcRuleWaitDriverOnOff     Wait for Driver On/Off Train>
//  - <l astSrcRuleWaitHTMLPages       Wait for HTML Pages>
//  - <l astSrcRuleWaitMinimap         Wait on Minimap Screen/Main Screen>
//  - <l astSrcRuleWaitTrainStopStart  Wait on Train Stop/Start>
//  - <l astSrcRuleWaitWaybill         Wait on Waybill Screen/Main Screen>
//
// See Also:
//     ConfigAssetHandler, GenericBoolHandler, AssetCheckListHandler, CheckListPropertyHandler, 
//     CheckListGroupHandler, EnumeratedAssetHandler, GenericStringHandler
//
class CheckBoxHandler isclass GenericBoolHandler
{
  // crude but necessary work-around :-/
  public void Init(Asset asset, string newConfigPrefix) { inherited(asset, newConfigPrefix); }


  //
  // Gets HTML page describing this object
  //
  public string GetDescriptionHTML(void)
  {
//    string boolLink = Link("boolValue") + "' tooltip='" + m_boolLinkTooltip + "'";
    string boolLink = Link("boolValue");
    string htmlPage = HTMLWindow.CheckBox(boolLink, m_boolValue) + " " + 
                                          m_assetStrTable.GetString(m_configPrefix + "-html-checkbox");
    return m_htmlPrefix + htmlPage + m_htmlSufix;
  }

};


//! A config asset handler that manages a list of Boolean properties where each property has a checkbox to set it.
//
// This class is similar to CheckBoxHandler in the way it uses a checkbox and adjacent text to allow a bool
// property value to be set, but instead of just one checkbox, it allows multiple checkboxes to be managed
// by the one handler, avoiding the need to use multiple CheckBoxHandler objects in a group handler.
//
// This config asset handler has a bool property value for each checkbox it contains.  The name for a bool
// checkbox property takes the form of <m "itemSetting/$N"> where $N is the index to the desired property 
// value.
//
// The amount of checkbox Boolean properties this handler has is based on how many sequential string table
// items matching a specific format appear in the host asset's string table.  When Init(Asset,string) is
// called, it will start looking for a string table item named <m "<config-prefix>-item0"> with 0 being the
// starting point.  It progressively keeps going looking for <m "<config-prefix>-item1"> and so on until it
// can't find any further string table elements in that sequence.
//
// Each of these <m "<config-prefix>-item$N"> string table elements should contain what is known as the 
// reference string.  The reference string is appended to the end of the config prefix string to find out
// the descriptive display text for that particular checkbox item.
//
// The string table requires for this config asset handler are listed in this table:
//
// {[ String Name                     | Description                                ]
//  [ "<config-prefix>-display-name"  | Display text to be shown before the list.  ]
//  [  |  ]
//  [ "<config-prefix>-item$N"        | Reference name for the $Nth item.          ]
//  [ "<config-prefix>-item-&lt;reference-name&gt;"  | Full name displayed next to the check box where
//                                                     &lt;reference name&gt; is the Xth item's reference
//                                                     name as defined in "<config prefix>-itemX".  ]
//  [  |  ]
//  [ "<config-prefix>-html-prefix"   | HTML code inserted at the start of the properties page.  ]
//  [ "<config-prefix>-html-sufix"    | HTML code inserted at the end of the properties page.    ]}
//
// For this config asset handler to work, it is essential that the item strings start from 0, are in an 
// unbroken linear order and each one has matching reference string.
//
// The <m "<config-prefix>-display-name"> string is an optional title/header that is placed above the list of
// checkboxes by this class' GetDescriptionHTML() implementation if included.  The same applies to both the 
// <m "<config-prefix>-html-prefix"> and <m "<config-prefix>-html-sufix"> string items which will be used to 
// wrap the generated HTML code up in if they are included.
//
// As an example, here are string table elements for a list of checkboxes taken from the 
// <l astSrcRuleEnaDisHUDIcons  Enable Disable HUD Icons> rule that defines a list of 4 checkboxes representing
// the four camera icons from the Driver interface.  The config prefix is <m "panel-camera-controls">.
//
// {[ String Name                           | Contents             ]
//  [ "panel-camera-controls-display-name"  | "Camera Controls:"   ]
//  [  |  ]
//  [ "panel-camera-controls-item0"         | "cab_View"           ]
//  [ "panel-camera-controls-item1"         | "chase_View"         ]
//  [ "panel-camera-controls-item2"         | "tracking_View"      ]
//  [ "panel-camera-controls-item3"         | "free_roaming_View"  ]
//  [  |  ]
//  [ "panel-camera-controls-item-cab_View"           | "Cab View"       ]
//  [ "panel-camera-controls-item-chase_View"         | "Chase View"     ]
//  [ "panel-camera-controls-item-tracking_View"      | "Tracking View"  ]
//  [ "panel-camera-controls-item-free_roaming_View"  | "Free Roaming"   ]
//  [  |  ]
//  [ "panel-camera-controls-html-prefix"   | "&lt;table cellpadding=0 cellspacing=0&gt;&lt;tr&gt;&lt;td width=3&gt;&lt;/td&gt;&lt;td&gt;&lt;font color=#000000&gt;"  ]
//  [ "panel-camera-controls-html-sufix"    | "&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;"  ]}
//
// The CheckListPropertyHandler class is also used by the following rules:
//  - <l astSrcRuleDisablIconNotif  Disabled HUD Icon Notification>
//  - <l astSrcRuleMapOptions       Minimap Options>
//  - <l astSrcRuleSetCamera        Set Camera>
//  - <l astSrcRuleSetHTMLPages     Set HTML Pages>
//
// See Also:
//     ConfigAssetHandler, CheckBoxHandler, RadioButtonListHandler, AssetCheckListHandler, 
//     CheckListGroupHandler, EnumeratedAssetHandler, GenericBoolHandler, GenericStringHandler
//
class CheckListPropertyHandler isclass ConfigAssetHandler
{
  string m_displayName = "";            // display name/text just above the list
  bool[] m_itemSettings = new bool[0];  // settings for check boxes (checked - true, unchecked - false)

  // names of string table entries where full text for the item can be found - synchronised to match itemSettings[]
  string[] m_itemNames = new string[0];


  //
  // Method definitions...
  //

  public void Init(Asset asset, string newConfigPrefix);

  public void Init(Asset asset, string newConfigPrefix, PropertyValue[] extraValues);
  public void InitBasics(Asset asset, string itemPrefix);


  //! Adds a new bool checkbox property to this handler.
  //
  // Note:
  //     This method was mainly written for internal use by Init(Asset,string) when it initializes this 
  //     handler.  Playing with it after the handler has been initialized <bi is not> recommended.
  //
  // Param:  itemName  Display text that will be displayed alongside the new checkbox property.
  // Param:  setting   Setting that the new checkbox property will initially have.
  //
  public void AddItem(string itemName, bool setting);

  //! Sets the state of the indexed checkbox bool property.
  //
  // Param:  itemIndex    Index of bool property set.  
  // Param:  itemChecked  State to set the checkbox specified by <i itemIndex> to.
  //
  public bool SetItem(int itemIndex, bool itemChecked);
  
  //! Sets all the checkbox bool properties of this handler to the given state.
  //
  // Param:  checked  Status to apply to all checkbox property items.  If true, they will all be checked,
  //         false to have all of them unchecked.
  //
  public void SetAll(bool checked);

  //! Gets the amount of bool property items in this handler.
  //
  // Returns:
  //     Returns the amount of bool property items in this handler.
  //
  public int CountItems();


  //! Gets the state of a bool check property by its item index.
  // 
  // Param:  index  Item number of bool property to get the value of.
  //
  // Returns:
  //     Returns the state of the bool property as specified by <i index>.
  //
  public bool     GetSetting(int index);

  //! Gets the state of all the bool checkbox properties as an array of bool values.
  //
  // Returns:
  //     Returns the state of all the bool checkbox properties as an array of bool values.
  //
  public bool[]   GetSettings(void) { return m_itemSettings; }

  //! Gets the state of all the bool checkbox properties as an integer bit set.
  //
  // Note: 
  //     As %Trainz GS only supports 32-bit integer values, this method is not suitable for checkbox lists
  //     with more than 32 items.
  //
  // Returns:
  //     Returns the state of all bool property values in a integer as a bit set.
  // 
  // See Also:
  //     Flags
  //
  public int      GetSettingsAsFlags(void);


  //! Gets the reference name of the bool checkbox property specified by <i index>.
  //
  // Param:  index  Item number of the bool property to get the reference name of.
  //
  // Returns:
  //     Returns the reference name of the bool checkbox property specified by <i index> if it exists, an 
  //     empty string (<m"">) otherwise.
  //
  public string   GetSettingName(int index);

  //! Gets the reference names for all of the bool checkbox properties in this handler.
  //
  // Returns:
  //     Returns all of the reference names in an array of strings.
  //
  public string[] GetSettingNames(void) { return m_itemNames; }

  //! Gets the reference names for all of the bool checkbox properties in this handler that match the given setting.
  //
  // Param:  checked  Status of the checkbox properties required for inclusion on the returned list.
  //
  // Returns:
  //     Returns all of the reference names of bool checkbox properties that match the state as specified in
  //     <i checked>.  If no bool properties match <i checked> the array will be empty.
  //
  public string[] GetSettingNames(bool checked);

  //! Gets the full display name of the specified bool checkbox property.
  //
  // Param:  index  Item number of the bool property to get the display name of.
  //
  // Returns:
  //     Returns the display name of the bool checkbox property specified by <i index> if it exists, an empty
  //     string (<m"">) otherwise.
  //
  public string   GetSettingDisplayName(int index);


  //! Determines if the bool checkbox property specified by <i index> exists in this handler.
  //
  // Param:  index  Item number of the bool property to verify the existence of.
  //
  // Returns:
  //     Returns true if the bool checkbox property specified by <i index> exists in this handler, false 
  //     otherwise.
  //
  public bool ItemExists(int index) { return (index >= 0)  and  (index < m_itemSettings.size()); }

  //! Determines if a bool checkbox property of the given name exists in this handler.
  //
  // Param:  itemName  Reference name of the item to verify the existence of.
  //
  // Returns:
  //     Returns the index of the bool property that matches <i itemName> if it exists, -1 otherwise.
  //
  public int  ItemExists(string itemName);

  //! Determines if a bool checkbox property of the given name and state exists in this handler.
  //
  // Param:  itemName  Reference name of the item to verify the existence of.
  // Param:  checkState  State that the bool property specified by <i itemName> should be in.
  //
  // Returns:
  //     Returns the index of the bool property that matches <i itemName> if it exists and its state matches
  //     <i checkState>, -1 otherwise.
  //
  public int  ItemExistsChecked(string itemName, bool checkState);


  //
  // Method imeplementations...
  //

  //
  // Allows automatic initialization via the asset's string table
  //
  public void Init(Asset asset, string newConfigPrefix)
  {
    inherited(asset, newConfigPrefix);

// now handled in InitBasics()
    // display name is "<itemPrefix>-display-name" from asset string table
//    m_displayName = m_assetStrTable.GetString(m_configPrefix + "-display-name");

    // determine the check list items based on string-table info
    int i = 0;
    while(true)
    {
      // we are expecting the string table to have "<itemPrefix>X" where X starts at 0 and
      // increments up. We know to stop when X is incremented and no string can be found.
      string itemString = m_assetStrTable.GetString(m_configPrefix + "-item" + (string)i);
      if (itemString.size())
      {
        me.AddItem(itemString, true);
        i++;
      }
      else
        break;
    }

  }

  //
  // extraValues:
  //  [0] - integer, amount of items in the checklist
  //
  public void Init(Asset asset, string newConfigPrefix, PropertyValue[] extraValues)
  {
    inherited(asset, newConfigPrefix, extraValues);

    // generate checklist items based on provided size value in extraValues[0]
    if (extraValues  and  extraValues.size())
      if (extraValues[0])
      {
        int checkListSize = extraValues[0].AsInt();
        if (checkListSize)
        {
          int i;
          for (i = 0; i < checkListSize; i++)
            me.AddItem(m_assetStrTable.GetString(m_configPrefix + "-item" + (string)i), true);
        }
      }

  }

  public void InitBasics(Asset asset, string itemPrefix)
  {
    inherited(asset, itemPrefix);
    m_displayName = m_assetStrTable.GetString(m_configPrefix + "-display-name");
  }


  //
  // Adds the given item as a checkbox at the end of the list.
  //
  public void AddItem(string itemName, bool setting)
  {
    m_itemNames[m_itemNames.size()] = itemName;
    m_itemSettings[m_itemSettings.size()] = setting;
  }

  //
  // Sets the indexed checkbox to the given state.
  //
  public bool SetItem(int itemIndex, bool itemChecked)
  {
    if ((itemIndex >= 0)  and  (itemIndex < m_itemSettings.size()))
    {
      m_itemSettings[itemIndex] = itemChecked;
      return true;
    }

    return false;
  }

  //
  // Sets all of the checkboxes in this list to the given state.
  //
  public void SetAll(bool checked)
  {
    int i;
    for (i = 0; i < m_itemSettings.size(); i++)
      m_itemSettings[i] = checked;
  }

  //
  // Gets the amount of checkbox items in this list.
  //
  public int CountItems(void)
  {
    if (m_itemSettings.size() == m_itemNames.size())
      return m_itemSettings.size();

    return 0;
  }

  //
  // Gets the current checked state for the 
  //
  public bool GetSetting(int index)
  {
    if ((index >= 0)  and  (index < m_itemSettings.size()))
      return m_itemSettings[index];

    return false; // not much good in a bool situation :-|
  }

  //
  // Gets all checkbox settings in a set of flags.
  //
  public int GetSettingsAsFlags(void)
  {
    int flagSet = 0;
    int bitCounter = 1;
    int i;
    for (i = 0; i < m_itemSettings.size(); i++)
    {
      if (m_itemSettings[i])
        flagSet = flagSet | bitCounter;

      bitCounter = bitCounter * 2;
    }
        
    return flagSet;
  }

  //
  // Gets the setting name for the indexed item.  This setting name can be used to reference the actual text
  // name in the host asset's string table.
  //
  public string GetSettingName(int index)
  {
    if ((index >= 0)  and  (index < m_itemNames.size()))
      return m_itemNames[index];

    return "";
  }

  //
  // Gets the nae of all checkbox items in the given state.
  //
  public string[] GetSettingNames(bool checked)
  {
    string[] resultsStr = new string[0];
    int i, q = 0;
    for (i = 0; i < m_itemSettings.size(); i++)
      if (m_itemSettings[i] == checked)
        resultsStr[q++] = m_itemNames[i];

    return resultsStr;
  }

  //
  // Gets the full display name of the indexed item.  This is retrieved from the host asset string table:
  //  - <config prefix> + "-item-" + <item setting name>
  //
  public string GetSettingDisplayName(int index)
  {
    if ((index >= 0)  and  (index < m_itemNames.size()))
      return m_assetStrTable.GetString(m_configPrefix + "-item-" + m_itemNames[index]); 

    return "";
  }

  //
  // Determins of the named checkbox item exists in the list and returns the index to it.
  // If it doesn't exist, -1 is returned.
  //
  public int ItemExists(string itemName)
  {
    int i;
    for (i = 0; i < m_itemNames.size(); i++)
      if (itemName == m_itemNames[i])
        return i;

    return -1;
  }

  //
  // ??
  //
  public int ItemExistsChecked(string itemName, bool checkState)
  {
    int index = ItemExists(itemName);
    if (index >= 0)
      if (m_itemSettings[index] == checkState)
        return index;

    return -1;
  }


  //
  // Property Handler methods
  //

  public string GetDescriptionHTML(void)
  {
    string htmlBody = "";
    if (m_displayName.size())
      htmlBody = m_displayName + "<br>";

    int i;
    for (i = 0; i < m_itemSettings.size(); i++)
      htmlBody = htmlBody + HTMLWindow.CheckBox(Link("itemSetting/" + i), m_itemSettings[i])
                          + " " + GetSettingDisplayName(i) + "<br>";

    return m_htmlPrefix + htmlBody + m_htmlSufix;
  }

  public string GetPropertyType(string propertyID)
  {
    string property = PropStripPrefix(propertyID, "");
    if (TrainUtil.GetUpTo(property, "/") == "itemSetting")
      return "link";

    return inherited(propertyID);
  }

  public void SetPropertyValue(string propertyID, PropertyValue value)
  {
    string property = PropStripPrefix(propertyID, "");
    if (TrainUtil.GetUpTo(property, "/") == "itemSetting")
    {
      int itemIndex = Str.ToInt(TrainUtil.GetAfter(property, "/"));
      m_itemSettings[itemIndex] = !m_itemSettings[itemIndex];
    }
    else
      inherited(propertyID, value);
  }

  public Soup GetProperties()
  {
    Soup soup = inherited();
    soup.SetNamedTag("CheckListPropertyHandler.displayName", m_displayName);
    
    Soup itemsSoup = Constructors.NewSoup();
    int i;
    for (i = 0; i < m_itemSettings.size(); i++)
    {
      string soupString = (int)m_itemSettings[i] + "/" + m_itemNames[i];
      itemsSoup.SetNamedTag((string)i, soupString);
    }

    soup.SetNamedSoup("CheckListPropertyHandler.items", itemsSoup);
    return soup;
  }

  public void SetProperties(Soup soup)
  {
    inherited(soup);

    Soup itemsSoup = soup.GetNamedSoup("CheckListPropertyHandler.items");
    int i = 0;
    while (true)
    {
      string nextItem = itemsSoup.GetNamedTag((string)i);
      if (nextItem  and  nextItem.size())
      {
        m_itemSettings[i] = Str.ToInt(TrainUtil.GetUpTo(nextItem, "/"));
        i++;
      }
      else
        break;
    }
  }

};


//! A config asset handler that provides a list of selectable checkboxes for all assets of a particular type.
//
// This handler is similar to CheckListPropertyHandler as it manages a collection of bool properties via a
// checklist interface, but this class is specifically made to provide a list of assets with checkboxes.
// This provides us with a handler that allows the selection of certain assets of a particular type.
//
// As this config handler builds up the checkbox items list automatically, the string table requirements are
// very minimal and simple:
//
// {[ String Name                       | Description                                                 ]
//  [ "<config-prefix>-asset-type"      | Type/kind of asset to populate the list with. Will be
//                                      overridden by category filter if provided.                    ]
//  [ "<config-prefix>-category-filter" | Category filter to search for assets with.                  ]
//  [ "<config-prefix>-display-name"    | Optional display text to be shown before the list.          ]
//  [  |  ]
//  [ "<config-prefix>-html-prefix"     | HTML code inserted at the start of the properties page.     ]
//  [ "<config-prefix>-html-sufix"      | HTML code inserted at the end of the properties page.       ]}
//
// The only essential string table requirement for this config handler is the <m "<config-prefix>-asset-type">
// string so the handler knows what type of asset to compile a list of types from.  If a valid type is not
// provided in this string table item, this handler <b WILL NOT> work.
//
// Note:
//     Different %Trainz installations have different assets installed.  When this handler saves its 
//     properties, it saves the state of each checkbox and the KUID of the asset represents.  When loading 
//     properties the existence of the loaded KUID is checked and if it doesn't exist, that asset will be 
//     ignored when re-initializing the handler.
//
// The <l astSrcRuleEnaDisDrivCmds  Enable/Disable Driver Commands> rule makes use of this class to select
// driver command assets.  Its string table settings for this handler with a config prefix of 
// <m "driver-cmd-list"> are:
//
// {[ String Name                     | Contents         ]
//  [ "driver-cmd-list-asset-type"    | "drivercommand"  ]
//  [ "driver-cmd-list-display-name"  | ""               ]
//  [ "driver-cmd-list-html-prefix"   | "&lt;tr&gt;&lt;td width=4&gt;&lt;/td&gt;&lt;td&gt;&lt;font color=#000000&gt;"  ]
//  [ "driver-cmd-list-html-sufix"    | "&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;"  ]}
//
// See Also:
//     ConfigAssetHandler, CheckBoxHandler, RadioButtonListHandler, CheckListPropertyHandler,
//     CheckListGroupHandler, EnumeratedAssetHandler, GenericBoolHandler, GenericStringHandler
//
class AssetCheckListHandler isclass ConfigAssetHandler
{
  string    m_assetType;                  // The asset 'kind' for this handler
  string    m_categoryFilter;             // The category filter to search with
  Asset[]   m_assetList = new Asset[0];   // List of displayed assets
  bool[]    m_itemSettings = new bool[0]; // Whether each asset in the lilst is checked/unchecked
  string    m_displayName = "";           // Display text for just above the list

  AsyncTrainzAssetSearchObject m_search;  // Active asset search. Cleared once search completes.


  public void Init(Asset asset, string newConfigPrefix);
  void StartNewAssetSearch();
  public int GetAssetIndex(Asset asset);
  public string GetAssetType(void) { return m_assetType; }
  public string GetAssetCategory(void) { return m_categoryFilter; }
  public Asset GetSettingAsset(int index);
  public Asset[] GetSettingAssets(bool checked);
  public int GetAssetIndex(Asset asset);


  //=============================================================================
  // Name: Init
  // Desc: Initialises this config handler from the asset and prefix passed
  //=============================================================================
  public void Init(Asset asset, string newConfigPrefix)
  {
    inherited(asset, newConfigPrefix);

    m_displayName = m_assetStrTable.GetString(m_configPrefix + "-display-name");
    if (m_displayName == "null")
      m_displayName = "";


    m_categoryFilter = m_assetStrTable.GetString(m_configPrefix + "-category-filter");
    if (m_categoryFilter == "")
    {
      m_assetType = m_assetStrTable.GetString(m_configPrefix + "-asset-type");
      if (m_assetType == "")
      {
        Interface.Exception("AssetCheckListHandler.Init> No asset type or category filter provided");
        return;
      }

      // The use of asset type/kind is obsolete, convert it to a category string
      m_categoryFilter = TrainzAssetSearch.GetCategoryStringForAssetKind(m_assetType);
      if (m_categoryFilter == "")
      {
        Interface.Exception("AssetCheckListHandler.Init> Unknown/invalid asset kind '" + m_assetType + "'");
        return;
      }
    }

    StartNewAssetSearch();

  }


  //=============================================================================
  // Name: StartNewAssetSearch
  // Desc: Internal function to start a new search using the current category
  //=============================================================================
  void StartNewAssetSearch()
  {
    if (m_search)
      Sniff(m_search, "TrainzAssetSearch", "AsyncResult", false);

    // Initialise and sniff the asset search object
    m_search = TrainzAssetSearch.NewAsyncSearchObject();
    AddHandler(me, "TrainzAssetSearch", "AsyncResult", "OnAssetSearchResult");
    Sniff(m_search, "TrainzAssetSearch", "AsyncResult", true);

    // Start the asset search
    int[] filterTypes = new int[3];
    string[] filterValues = new string[3];
    filterTypes[0] = TrainzAssetSearch.FILTER_LOCATION;   filterValues[0] = "local";
    filterTypes[1] = TrainzAssetSearch.FILTER_VALID;      filterValues[1] = "true";
    filterTypes[2] = TrainzAssetSearch.FILTER_CATEGORY;   filterValues[2] = m_categoryFilter;

    TrainzAssetSearch.AsyncSearchAssetsSorted(filterTypes, filterValues, TrainzAssetSearch.SORT_NAME, true, m_search);

    // TODO: Trigger HTML refresh
  }


  //=============================================================================
  // Name: OnAssetSearchResult
  // Desc: Handler for the asynchronous asset search
  //=============================================================================
  void OnAssetSearchResult(Message msg)
  {
    // Save the old lists so any previous values can be restored
    Asset[] oldList = m_assetList;
    bool[] oldSettings = m_itemSettings;


    // Set the new asset list from the search and create a new settings array
    m_assetList = m_search.GetResults();
    m_itemSettings = new bool[m_assetList.size()];

    
    // Default new items to off/unchecked
    int i;
    for (i = 0; i < m_itemSettings.size(); ++i)
      m_itemSettings[i] = false;

    if (oldList and oldSettings)
    {
      // Attempt to restore any previous values
      for (i = 0; i < oldSettings.size(); ++i)
      {
        if (!oldSettings[i])
          continue;

        // Found an enabled asset, check if it's in the new list
        int j;
        for (j = 0; j < m_assetList.size(); ++j)
        {
          if (m_assetList[j] == oldList[i])
          {
            // Found it, enable it again
            m_itemSettings[j] = true;
            break;
          }
        }
      }
    }


    // Unsniff and clear the search object
    Sniff(m_search, "TrainzAssetSearch", "AsyncResult", false);
    m_search = null;

    // TODO: Trigger HTML refresh
  }


  //=============================================================================
  // Name: GetSettingAsset
  // Desc: Returns an asset by index
  //=============================================================================
  public Asset GetSettingAsset(int index)
  {
    if (index >= 0 and index < m_assetList.size())
      return m_assetList[index];

    return null;
  }


  //=============================================================================
  // Name: GetSettingAssets
  // Desc: Returns a list of assets matching the checked status passed
  //=============================================================================
  public Asset[] GetSettingAssets(bool checked)
  {
    Asset[] resultList = new Asset[0];

    int i;
    for (i = 0; i < m_assetList.size(); ++i)
    {
      if (m_itemSettings[i] == checked)
        resultList[resultList.size()] = m_assetList[i];
    }

    return resultList;
  }


  //=============================================================================
  // Name: GetAssetIndex
  // Desc: Searches for the asset passed in this list and returns its index if
  //       found, or -1 if not found
  //=============================================================================
  public int GetAssetIndex(Asset asset)
  {
    if (asset)
    {
      int i;
      for (i = 0; i < m_assetList.size(); ++i)
      {
        if (m_assetList[i] == asset)
          return i;
      }
    }

    return -1;
  }


  //=============================================================================
  // Name: GetDescriptionHTML
  // Desc: Returns a html description for this handler for display in game
  //=============================================================================
  public string GetDescriptionHTML(void)
  {
    string htmlBody = "";
    if (m_displayName.size())
      htmlBody = m_displayName + "<br>";

    if (m_search)
    {
      StringTable coreStrings = Constructors.GetTrainzStrings();
      htmlBody = htmlBody + coreStrings.GetString("interface-helper-loading-assets") + "<br>";
    }
    else
    {
      int i;
      for (i = 0; i < m_assetList.size(); ++i)
      {
        htmlBody = htmlBody + HTMLWindow.CheckBox(Link("itemSetting/" + i), m_itemSettings[i])
                            + "  " + m_assetList[i].GetLocalisedName() + "<br>";
      }
    }

    return m_htmlPrefix + htmlBody + m_htmlSufix;
  }


  //=============================================================================
  // Name: GetPropertyType
  // Desc: Returns the property type for the property with the ID passed
  //=============================================================================
  public string GetPropertyType(string prefixedPropertyID)
  {
    string propertyID = PropStripPrefix(prefixedPropertyID, "");
    if (propertyID == "assetType")
      return "string";

    if (TrainUtil.GetUpTo(propertyID, "/") == "itemSetting")
      return "link";

    return inherited(prefixedPropertyID);
  }


  //=============================================================================
  // Name: SetPropertyValue
  // Desc: Sets the value of a property
  //=============================================================================
  public void SetPropertyValue(string prefixedPropertyID, PropertyValue value)
  {
    string propertyID = PropStripPrefix(prefixedPropertyID, "");
    if (propertyID == "assetType")
    {
      m_assetType = value.AsString();
      return;
    }

    if (TrainUtil.GetUpTo(propertyID, "/") == "itemSetting")
    {
      int itemIndex = Str.ToInt(TrainUtil.GetAfter(propertyID, "/"));
      m_itemSettings[itemIndex] = !m_itemSettings[itemIndex];
      return;
    }

    inherited(prefixedPropertyID, value);
  }


  //=============================================================================
  // Name: GetProperties
  // Desc: Return properties of this object in a soup, for save/load support
  //=============================================================================
  public Soup GetProperties()
  {
    Soup soup = inherited();
    soup.SetNamedTag("AssetCheckListHandler.assetType", m_assetType);
    soup.SetNamedTag("AssetCheckListHandler.category-filter", m_categoryFilter);

    // Save the enabled/checked asset list to a sub-soup
    Soup itemsSoup = Constructors.NewSoup();

    int i;
    for (i = 0; i < m_itemSettings.size(); i++)
    {
      if (m_assetList[i] and m_itemSettings[i])
        itemsSoup.SetNamedTag((string)i, m_assetList[i].GetKUID());
    }
    soup.SetNamedSoup("AssetCheckListHandler.items", itemsSoup);

    return soup;
  }


  //=============================================================================
  // Name: SetProperties
  // Desc: Initialises this handler from the soup passed, for save/load support
  //=============================================================================
  public void SetProperties(Soup soup)
  {
    inherited(soup);

    // Only load asset type if it isn't already set, as Init may have loaded a
    // newer value from the host string-table
    if (m_assetType == "" and m_categoryFilter == "")
    {
      m_categoryFilter = soup.GetNamedTag("AssetCheckListHandler.category-filter");
      m_assetType = soup.GetNamedTag("AssetCheckListHandler.assetType");

      if (m_assetType != "" and m_categoryFilter == "")
        m_categoryFilter = TrainzAssetSearch.GetCategoryStringForAssetKind(m_assetType);

      StartNewAssetSearch();
    }

    int i;

    // If there's no search then we need to clear any existing settings, as
    // only checked assets are saved in GetProperties
    if (!m_search)
    {
      for (i = 0; i < m_itemSettings.size(); ++i)
        m_itemSettings[i] = false;
    }

    Soup itemsSoup = soup.GetNamedSoup("AssetCheckListHandler.items");
    for (i = 0; i < itemsSoup.CountTags(); ++i)
    {
      KUID itemKuid = itemsSoup.GetNamedTagAsKUID(itemsSoup.GetIndexedTagName(i));
      if (!itemKuid)
        continue;

      if (m_search)
      {
        // While the search is active we'll set these items straight to the
        // internal array. When the search completes OnAssetSearchResult will
        // attempt to restore them to the new search results.
        Asset asset = World.FindAsset(itemKuid);

        // TODO: Should really also check that the asset matches the current
        // category filter, but the old implementation never did.
        if (asset)
        {
          m_assetList[m_assetList.size()] = asset;
          m_itemSettings[m_itemSettings.size()] = true;
        }
      }
      else
      {
        // The search is already complete, attempt to find this asset in the
        // array and make sure it's checked.
        KUID baseItemKuid = itemKuid.GetBaseKUID();

        int j;
        for (j = 0; j < m_assetList.size(); ++j)
        {
          if (m_assetList[j].GetKUID().GetBaseKUID() == baseItemKuid)
          {
            // Found a version of the asset, enable it
            m_itemSettings[j] = true;
            break;
          }
        }
      }

    } // for (i = 0; i < itemsSoup.CountTags(); ++i)

  }

};



//! A config asset handler that manages a list of text items with radio buttons.
//
// This handler provides a list of text items where each one has an adjacent radio button and only one can be
// selected at a time (which is how radio buttons generally behavior in GUI environments).  This means 
// selecting one item results in the currently selected item becoming de-selected.  
//
// The key property of this handler is a current selection value that refers to the index of the currently 
// selected radio button item.  This is the only property value that this handler saves/loads.  The text items
// are read from the string table each time the handler is created.
//
// This class is derived from CheckListPropertyHandler and is configured from a host string table in an almost
// identical way:
//
// {[ String Name                     | Description                                ]
//  [ "<config-prefix>-display-name"  | Display text to be shown before the list.  ]
//  [ "<config-prefix>-item$N"        | Reference name for the $Nth item.          ]
//  [ "<config-prefix>-item-&lt;reference-name&gt;"  | Full name displayed next to the radio button where
//                                                     &lt;reference name&gt; is the Xth item's reference
//                                                     name as defined in <m "<config-prefix>-itemX">.  ]
//  [  |  ]
//  [ "<config-prefix>-html-prefix"   | HTML code inserted at the start of the properties page.  ]
//  [ "<config-prefix>-html-sufix"    | HTML code inserted at the end of the properties page.    ]}
//
// The listing of items to use next to each radio button for example is identical to that of 
// CheckListPropertyHandler where you have the <m "<config-prefix>-item$N"> strings in a numbered sequence
// and each one of these strings contains the reference name for that item.  The actual text for the item
// is found by using the reference name appended to the end of the config prefix.
//
// The currently selected item can be obtained by using CheckListPropertyHandler methods such as 
// GetSettingNames(bool).  As this class only has one item selected at once, GetSettingNames(bool) can be
// relied on to return an array with just one string in it that will be the name of the currently selected
// item for example.
//
// No assets currently use this handler class, but as a simple example here is a list of string table entries
// that when used with this handler will allow a junction direction setting to be selected.  The config prefix
// is <m "junc-mode">.
//
// {[ String Name               | Contents                          ]
//  [ "junc-mode-display-name"  | "Change junction direction to: "  ]
//  [  |  ]
//  [ "junc-mode-item0"         | "left"    ]
//  [ "junc-mode-item1"         | "center"  ]
//  [ "junc-mode-item2"         | "right"   ]
//  [  |  ]
//  [ "junc-mode-item-left"     | "Left"    ]
//  [ "junc-mode-item-center"   | "Center (3-way junctions only)"   ]
//  [ "junc-mode-item-left"     | "Right"   ]}
//
// See Also:
//     ConfigAssetHandler, CheckBoxHandler, CheckListPropertyHandler, CheckListGroupHandler, 
//     RadioButtonGroupHandler, AssetCheckListHandler, EnumeratedAssetHandler, GenericStringHandler 
//
class RadioButtonListHandler isclass CheckListPropertyHandler
{
  int m_currentSelection = 0; //!< Index to currently selected radio button item.

  public void Init(Asset asset, string newConfigPrefix);

  //! Adds the given item to the list of radio buttons this handler has.
  //
  // This method is overridden in RadioButtonListHandler so that every time a new item is added, the radio 
  // buttons are reset with ResetButtons() if needed.  The buttons will only be reset if <i setting> is true
  // as only one item in a radio button list can be selected.
  //
  // Note:
  //     This method was mainly written for internal use by Init(Asset,string) when it initializes this 
  //     handler.  Playing with it after the handler has been initialized <bi is not> recommended.
  //
  // Param:  itemName  Display text that will be displayed alongside the new radio button property.
  // Param:  setting   On/off state of the radio button.  If true, the radio button for this item is selected
  //                   and all of the other radio buttons will be <l ResetButtons() reset>.
  //
  public void AddItem(string itemName, bool setting);

  //! Resets the radio buttons of this handler such that all are false except the currently selected one.
  //
  // This is a handy method to call whenever a new radio button item is added or selected to ensure the list
  // of radio buttons only has one item selected.
  //
  public void ResetButtons(void);


  //
  // Method implementation
  //

  public void Init(Asset asset, string newConfigPrefix) 
  { 
    inherited(asset, newConfigPrefix); 
    m_currentSelection = 0; // we have the first item set by default
    ResetButtons();  
  }

  // adds a new item
  public void AddItem(string itemName, bool setting)
  {
    int newItemIndex = m_itemSettings.size();
    m_itemSettings[newItemIndex] = setting;
    m_itemNames[newItemIndex] = itemName;

    if (setting)
    {
      m_currentSelection = newItemIndex;
      ResetButtons();
    }
  }

  // resets the radio buttons
  public void ResetButtons(void)
  {
    if ((m_currentSelection < 0)  or  (m_currentSelection >= m_itemSettings.size()))
      m_currentSelection = 0; // reset to 0 (the first one) as a default

    int i;
    for (i = 0; i < m_itemSettings.size(); i++)
      m_itemSettings[i] = false;

    m_itemSettings[m_currentSelection] = true; // we only have one button set and that is the current one!
  }


  //
  // Property handler methods 
  //

  public string GetDescriptionHTML(void)
  {
    string htmlBody = m_displayName + "<br>";
    int i;
    for (i = 0; i < m_itemSettings.size(); i++)
      htmlBody = htmlBody + HTMLWindow.RadioButton(Link("itemSetting/" + i), m_itemSettings[i]) + " " +
                 GetSettingDisplayName(i) + "<br>";

    htmlBody = htmlBody + "<br>";
    return m_htmlPrefix + htmlBody + m_htmlSufix;
  }

  public void SetPropertyValue(string propertyID, PropertyValue value)
  {
    string property = PropStripPrefix(propertyID, "");
    if (TrainUtil.GetUpTo(property, "/") == "itemSetting")
    {
      int itemIndex = Str.ToInt(TrainUtil.GetAfter(property, "/"));
      m_itemSettings[itemIndex] = !m_itemSettings[itemIndex];
      m_currentSelection = itemIndex;
      ResetButtons();
      return;
    }

    inherited(propertyID, value); // dw: needed?
  }

  public Soup GetProperties()
  {
    Soup soup = inherited();
    soup.SetNamedTag("RadioButtonListHandler.currentSelection", m_currentSelection);
    return soup;
  }

  public void SetProperties(Soup soup)
  {
    inherited(soup);
    m_currentSelection = soup.GetNamedTagAsInt("RadioButtonListHandler.currentSelection", m_currentSelection);
  }

};



//! A checklist of items where each item is a child handler.
//
// This config handler is a group handler that has a selectable checkbox for each child handler.  It works in
// a similar way to CheckListPropertyHandler but instead relies on the child handler to provide content to go
// beside the checkbox.
//
// Apart from the child handler's HTML page being place adjacent to a checkbox this handler class creates, 
// the checkboxes don't affect the child handlers and vice versa - they are separate entities.  %Interface
// methods are provided with this class so the state of the checkbox can be queried but what the programmer
// decides to use the checkbox value is entirely up to them.
//
// The checkboxes are a mechanism for a sub handler to be easily selected/deselected.  What selecting or
// deselecting a particular sub handler may actually mean is up to the programmer.  It is assumed that as
// they are creating and adding the sub handlers, they know actually know what these sub handlers do.
//
// Due to the more complex nature of a group handler having sub handlers, this config handler class is 
// trickier to setup and use then the basic CheckListPropertyHandler class is.  The string table requirements
// for this class are:
//
// {[ String Name                           | Description                               ]
//  [ "<config-prefix>-display-name"        | Display name to be above the list.        ]
//  [ "<config-prefix>-html-between-items"  | HTML code placed between each checkbox and child handler in
//                                            this group handler's properties window.  Useful for adding a
//                                            line break or divider bar.                ]
//  [ "<config-prefix>-&lt;item-name&gt;"   | Optional title for the child handler.  If included, this text
//                                            will be placed next to the checkbox and above the child handler
//                                            with a prefix of <m "&lt;item-name&gt">.  ]
//  [  |  ]
//  [ "<config-prefix>-html-prefix"         | HTML code inserted at the start of the properties page.  ]
//  [ "<config-prefix>-html-sufix"          | HTML code inserted at the end of the properties page.    ]}
//
// For example here are the string table items from the <l astSrcRuleSetCamera  Set Camera> rule where the 
// config prefix is <m "set-camera">:
//
// {[ String Name                      | Contents      ]
//  [ "set-camera-display-name"        | "Perform the following operations on the in-game camera:&lt;br&gt;"  ]
//  [ "set-camera-html-between-items"  | "&lt;br&gt;"  ]
//  [  |  ]
//  [ "set-camera-item-cameratarget"   | "null"        ]
//  [ "set-camera-item-cameramode"     | "null"        ]
//  [ "set-camera-item-cameraflags"    | "null"        ]
//  [  |  ]
//  [ "set-camera-html-prefix"         | "&lt;table cellpadding=0 cellspacing=0&gt;&lt;tr height=1&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td width=3&gt;&lt;/td&gt;&lt;td&gt;&lt;font color=#000000&gt;"  ]
//  [ "set-camera-html-sufix"          | "&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;"  ]}
//
// Note that the <m "set-camera-item-X"> strings correspond to the 3 sub handlers used by the 
// <l astSrcRuleSetCamera  Set Camera> rule with this class.
//
// This handler is also used by <l astSrcRuleDispHTMLPages  Display HTML Pages> rule.
//
// Useful interface methods provided with this class are:
//  - public void                 <b AddItem>                (string itemName, bool setting)
//  - public bool                 <b GetSetting>             (int index)
//  - public bool[]               <b GetSettings>            ()
//  - public string               <b GetSettingName>         (int index)
//  - public string[]             <b GetSettingNames>        ()
//  - public string[]             <b GetSettingNames>        (bool checked)
//  - public string               <b GetSettingDisplayName>  (int index)
//  - public HTMLPropertyHandler  <b GetItemSubHandler>      (int index)
//
// Note:
//     CheckListGroupHandler was mainly written as a utility class for use in the TRS2006 session rules.  It
//     is not part of the core %Trainz API and is not fully documented.  Those who are interested in how this
//     class works can see all the full implementation in the <b \Trainz\scripts\ListItemPropertyHandler.gs>
//     script file.
//
// See Also:
//     CheckListPropertyHandler, RadioButtonGroupHandler, RadioButtonListHandler, ConfigAssetGroupHandler,
//     AssetCheckListHandler, CheckBoxHandler, EnumeratedPropertyHandler, GenericStringHandler
//
class CheckListGroupHandler isclass ConfigAssetGroupHandler
{
  string m_displayName = "";            // display name/text just above the list
  string m_htmlBetweenItems = "";       // text to display between each item (line break etc.)
  bool[] m_itemSettings = new bool[0];  // settings for check boxes (checked - true, unchecked - false)

  // names of string table entries where full text for the item can be found
  string[] m_itemNames = new string[0];

  // actual text data for item (if empty, it means config file doesn't have it)
  string[] m_itemDisplayNames = new string[0];

  // are sub-handlers displayed regardless (true), or are they only displayed when their corresponding check
  // item is enabled (false)
  bool m_subHandlersCheckVisible = true;


  //
  // Method definitions
  //

  public void Init(Asset asset, string newConfigPrefix);


  //@ Adds a new bool checkbox property to this handler. 
  //
  // Note:
  //     This method was mainly written for internal use by the overridden AddHandler() method of this class
  //     such that it is automatically called to create a new check box for each new child handler as needed.
  //     Use of this method <bi IS NOT RECOMMENDED>.
  //
  // Param:  itemName  Referece Display text that will be displayed alongside the new checkbox property.
  //                   Use a blank string (<m"">) or <m "null"> if you don't want a display string to
  //                   appear beside the checkbox and above the child handler.
  // Param:  setting   Setting that the new checkbox item will initially have.
  //
  public void AddItem(string itemName, bool setting);

  //@ Get setting indexed.
  //
  // Param:  index  ??
  //
  // Returns:
  //     ??
  //
  public bool     GetSetting(int index);
  
  //@ Gets all checkbox settings as an array of bools.
  //
  // Returns:
  //     ??
  //
  public bool[]   GetSettings(void) { return m_itemSettings; }
  
  //@ Gets the reference name of the index value.
  //
  // Param:  index  ??
  //
  // Returns:
  //     ??
  //
  public string   GetSettingName(int index);
  
  //@ Gets the reference names of all checkbox items.
  //
  // Returns:
  //     ??
  //
  public string[] GetSettingNames(void) { return m_itemNames; }
  
  //@ Gets the reference names of the settings checked to the set value.
  //
  // Param:  checked  ??
  //
  // Returns:
  //     ??
  //
  public string[] GetSettingNames(bool checked);
  
  //@ Gets the display name of the indexed setting.
  //
  // Param:  index  ??
  //
  // Returns:
  //     ??
  //
  public string   GetSettingDisplayName(int index);

  //@ Gets the sun-handler for the indexed item.
  //
  // Param:  index  ??
  //
  // Returns:
  //     ??
  //
  public HTMLPropertyHandler GetItemSubHandler(int index);


  string GetHTMLButton(string urlString, bool setting);


  //
  // Method implementations
  //

  // initialization
  public void Init(Asset asset, string newConfigPrefix)
  {
    inherited(asset, newConfigPrefix);

    // display name is "<newConfigPrefix>-display-name" from asset string table
    if (!m_displayName.size())
    {
      m_displayName = m_assetStrTable.GetString(m_configPrefix + "-display-name");
      if (m_displayName == "null")
        m_displayName = "";
    }

    if (!m_htmlBetweenItems.size())
      m_htmlBetweenItems = m_assetStrTable.GetString(m_configPrefix + "-html-between-items");
  }

  //
  // Adds the given item to the list of check-boxes
  //
  public void AddItem(string itemName, bool setting)
  {
    m_itemNames[m_itemNames.size()] = itemName;

    string tempItemName = m_assetStrTable.GetString(m_configPrefix + "-item-" + itemName);
    if (tempItemName == "null")
      m_itemDisplayNames[m_itemDisplayNames.size()] = "";
    else
      m_itemDisplayNames[m_itemDisplayNames.size()] = tempItemName;
//    m_itemDisplayNames[m_itemDisplayNames.size()] = m_assetStrTable.GetString(m_configPrefix + "-item-" + itemName);

    m_itemSettings[m_itemSettings.size()] = setting;
  }

  //
  // For each sub handler, automatically add a checkbox/radio button item for it.
  //
  public void AddHandler(HTMLPropertyHandler handler, string subPrefix)
  {
    inherited(handler, subPrefix + "/item/");
    me.AddItem(subPrefix, false);
  }

  public bool GetSetting(int index)
  {
    if ((index >= 0)  and  (index < m_itemSettings.size()))
      return m_itemSettings[index];

    return false; // not much good in a bool situation :-|
  }

  public string GetSettingName(int index)
  {
    if ((index >= 0)  and  (index < m_itemNames.size()))
      return m_itemNames[index];

    return "";
  }

  public string[] GetSettingNames(bool checked)
  {
    string[] resultsStr = new string[0];
    int i, q = 0;
    for (i = 0; i < m_itemSettings.size(); i++)
      if (m_itemSettings[i] == checked)
        resultsStr[q++] = m_itemNames[i];

    return resultsStr;
  }

  public string GetSettingDisplayName(int index)
  {
    if ((index >= 0)  and  (index < m_itemNames.size()))
      return m_itemDisplayNames[index];

    return "";
  }

  public HTMLPropertyHandler GetItemSubHandler(int index)
  {
    if ((index >= 0)  and  (index < handlers.size()))
      if ((index < m_itemSettings.size())  and  handlers[index])
        return handlers[index];

    return null;
  }

  //
  // ??
  //
  string GetHTMLButton(string urlString, bool setting)
  {
    return HTMLWindow.CheckBox(urlString, setting);
  }


  //
  // Property Handler methods
  //

  public string GetDescriptionHTML(void)
  {
    string htmlBody = "";

    if (m_displayName.size())
      htmlBody = htmlBody + m_displayName + "<br>";

    int i;
    for (i = 0; i < m_itemSettings.size(); i++)
    {
      string displayName = GetSettingDisplayName(i);
      string buttonHTML = GetHTMLButton(Link("itemSetting/" + i), m_itemSettings[i]);

      HTMLPropertyHandler tempHandler = FindHandler(Prop(m_itemNames[i]) + "/item/");
      if (tempHandler)
      {
        // if there is no display name, put sub-handler adjacent to the radiobutton
        if (!displayName.size())
          htmlBody = htmlBody + 
            "<table border='0' cellspacing='0' cellpadding='0'><tr><td>" + buttonHTML + "</td><td>" + 
              tempHandler.GetDescriptionHTML() + 
            "</td></tr></table>";
        else
          htmlBody = htmlBody +
            "<table border='0' cellspacing='0' cellpadding='0'><tr><td>" +
              buttonHTML + "</td><td>" + displayName + "</td></tr>" +
              "<tr><td></td><td><table bordercolor=#00000059 border=3><tr><td>" + 
                tempHandler.GetDescriptionHTML() +
              "</td><td width=10%></td></tr></table>" +
            "</td></tr></table>";
      }
      // if no sub-handler, just use the item on it's own (at this stage, we will assume there is item name data to use!)
      else
        htmlBody = htmlBody + "<table border='0' cellspacing='0' cellpadding='0'><tr><td>" + buttonHTML + "</td><td>" + displayName + "</td></tr></table>";
        
      // if it's not the last item, then put in the html-between thingy
      if (i < (m_itemSettings.size() - 1))
        htmlBody = htmlBody + m_htmlBetweenItems;
    }

    return m_htmlPrefix + htmlBody + m_htmlSufix;
  }

  public string GetPropertyType(string propertyID)
  {
    string property = PropStripPrefix(propertyID, "");
    if (TrainUtil.GetUpTo(property, "/") == "itemSetting")
      return "link";

    return inherited(propertyID);
  }

  public void SetPropertyValue(string propertyID, PropertyValue value)
  {
    string property = PropStripPrefix(propertyID, "");
    if (TrainUtil.GetUpTo(property, "/") == "itemSetting")
    {
      int itemIndex = Str.ToInt(TrainUtil.GetAfter(property, "/"));
      m_itemSettings[itemIndex] = !m_itemSettings[itemIndex];
      return;
    }

    inherited(propertyID, value);
  }

  public Soup GetProperties()
  {
    Soup soup = inherited();
//    soup.SetNamedTag("CheckListGroupHandler.displayName", m_displayName);

    Soup itemsSoup = Constructors.NewSoup();
    int i;
    for (i = 0; i < m_itemSettings.size(); i++)
      itemsSoup.SetNamedTag((string)i, (int)m_itemSettings[i] + "/" + m_itemNames[i]);

    soup.SetNamedSoup("CheckListGroupHandler.items", itemsSoup);

    // sub handlers - need to do this as parent class doesn't use HTMLPropertyGroup saving
    Soup subHandlerSoup = Constructors.NewSoup();
    for (i = 0; i < handlers.size(); i++)
    {
      if (handlers[i].GetSavesProperties())
      {
        string prefix = handlers[i].GetPrefix();
        if (prefix == "")
          prefix = "<null>";

        Soup subsoup = handlers[i].GetProperties();
        subHandlerSoup.SetNamedSoup(prefix, subsoup);
      }
    }

    soup.SetNamedSoup("CheckListGroupHandler.subHandlers", subHandlerSoup);

    return soup;
  }

  public void SetProperties(Soup soup)
  {
    inherited(soup);
    
    // if it has been set to something new in Init, we want that to filter through, not the saved string
//    if (!m_displayName.size())
//      m_displayName = soup.GetNamedTag("CheckListGroupHandler.displayName");

    Soup itemsSoup = soup.GetNamedSoup("CheckListGroupHandler.items");

//    m_itemSettings = new bool[0];
//    m_itemNames = new string[0];
    int i = 0;
    for (i = 0; i < itemsSoup.CountTags(); i++)
    {
      string nextItem = itemsSoup.GetNamedTag((string)i);
      if (nextItem  and  nextItem.size())
      {
        string[] itemTokens = Str.Tokens(nextItem, "/");
        m_itemSettings[i] = Str.ToInt(itemTokens[0]);
        // only load if we don't already have an itemname in the array
        if (!m_itemNames[i].size())
          m_itemNames[i] = itemTokens[1];
      }
    }

    // sub handlers - need to do this as parent class doesn't use HTMLPropertyGroup saving
    Soup subHandlerSoup = soup.GetNamedSoup("CheckListGroupHandler.subHandlers");
    for (i = 0; i < handlers.size(); i++)
    {
      if (handlers[i].GetSavesProperties())
      {
        string prefix = handlers[i].GetPrefix();
        if (prefix == "")
          prefix = "<null>"; // stolen from HTMLPropertyGroupHandler!

        Soup subSoup = subHandlerSoup.GetNamedSoup(prefix);
        if (subSoup.CountTags())
          handlers[i].SetProperties(subSoup);
      }
    }
  }

};



//! A config asset handler that provides selection of a child handler with radio buttons.
//
// This config handler is a group handler that has a selectable radio button for each child handler.  It
// works in a similar way to RadioButtonListHandler but instead relies on the child handler to provide 
// content to go beside the checkbox.  Is designed to be generic to the point where any handler class could
// be a selectable item.
//
// Apart from the child handler's HTML page being place adjacent to the radio button this handler class 
// creates, the radio buttons don't affect the child handlers and vice versa - they are separate entities.
// %Interface methods are provided with this class so the state of a radio button can be queried.
//
// This class is derived from CheckListGroupHandler and is configured from a host string table in an almost 
// identical way:
//
// {[ String Name                           | Description                               ]
//  [ "<config-prefix>-display-name"        | Display name to be above the list.        ]
//  [ "<config-prefix>-html-between-items"  | HTML code placed between each radio button and child handler
//                                            in this group handler's properties window.  Useful for adding
//                                            a line break or divider bar for example.  ]
//  [ "<config-prefix>-&lt;item-name&gt;"   | Optional title for the child handler.  If included, this text
//                                            will be placed next to the radio button and above the child 
//                                            handler with a prefix of <m "&lt;item-name&gt">.  ]
//  [  |  ]
//  [ "<config-prefix>-html-prefix"         | HTML code inserted at the start of the properties page.  ]
//  [ "<config-prefix>-html-sufix"          | HTML code inserted at the end of the properties page.    ]}
//
// For example here are the string table items from the <l astSrcRuleMessagePop  Message Popup> rule where 
// the config prefix is <m "popup-selection">:
//
// {[ String Name                           | Contents  ]
//  [ "popup-selection-display-name"        | "Create a pop-up message box window from:"  ]
//  [ "popup-selection-html-between-items"  | " "       ]
//  [  |  ]
//  [ "popup-selection-item-msgboxasset"    | "null"    ]
//  [ "popup-selection-item-msgboxtext"     | "null"    ]
//  [  |  ]
//  [ "popup-selection-html-prefix"         | "&lt;font color=#000000&gt;"  ]
//  [ "popup-selection-html-sufix"          | "&lt;/font&gt;"               ]}
//
// Note that the <m "popup-selection-item-X"> strings correspond to the two sub handlers used by the 
// <l astSrcRuleMessagePop  Message Popup> rule with this class.
//
// This handler is also used by the following rules:
//  - <l astSrcRuleFlashHUDIcon   Flash HUD Icon>
//  - <l astSrcRuleFlashHUDPanel  Flash HUD Panel>
//  - <l astSrcRuleSetCamera      Set Camera>
//  - <l astSrcRuleSetHTMLPages   Set HTML Pages>
//  - <l astSrcRuleWaitHTMLPages  Wait HTML Pages>
//
// Useful interface methods provided with this class are:
//  - public void                 <b AddItem>                (string itemName, bool setting) (overridden from CheckListGroupHandler)
//  - public HTMLPropertyHandler  <b GetSelectedSubHandler>  ()
//  - public void                 <b ResetButtons>           ()
//
// As well as that, the following methods inherited from CheckListGroupHandler are also applicable to this class:
//  - public bool                 <b GetSetting>             (int index)
//  - public bool[]               <b GetSettings>            ()
//  - public string               <b GetSettingName>         (int index)
//  - public string[]             <b GetSettingNames>        ()
//  - public string[]             <b GetSettingNames>        (bool checked)
//  - public string               <b GetSettingDisplayName>  (int index)
//  - public HTMLPropertyHandler  <b GetItemSubHandler>      (int index)
//
// Note:
//     RadioButtonGroupHandler was mainly written as a utility class for use in the TRS2006 session rules.  It
//     is not part of the core %Trainz API and is not fully documented.  Those who are interested in how this
//     class works can see all the full implementation in the <b \Trainz\scripts\ListItemPropertyHandler.gs>
//     script file.
//
// See Also:
//     RadioButtonListHandler, CheckListGroupHandler, CheckListPropertyHandler, ConfigAssetGroupHandler, 
//     AssetCheckListHandler, CheckBoxHandler, EnumeratedPropertyHandler, GenericStringHandler
//
class RadioButtonGroupHandler isclass CheckListGroupHandler
{
  int m_currentSelection = 0;

  //
  // Method definitions
  //

  public void Init(Asset asset, string newConfigPrefix);


  //@ Document me!
  //
  // Param:  itemName  ??
  // Param:  setting   ??
  //
  public void AddItem(string itemName, bool setting);
  
  //@ Document me!
  public void ResetButtons(void);

  //@ Document me!
  //
  // Returns:
  //     ??
  //
  public HTMLPropertyHandler GetSelectedSubHandler(void);

  string GetHTMLButton(string urlString, bool setting);


  //
  // Method implementations
  //

  public void Init(Asset asset, string newConfigPrefix)
  {
    inherited(asset, newConfigPrefix);

    m_currentSelection = 0; // we have the first item set by default
    ResetButtons();
  }

  // Adds the given item to the list of radio buttons.
  public void AddItem(string itemName, bool setting)
  {
    m_itemSettings[m_itemSettings.size()] = setting; // generally should be false (for now)
    m_itemNames[m_itemNames.size()] = itemName;

//    m_itemDisplayNames[m_itemDisplayNames.size()] = m_assetStrTable.GetString(m_configPrefix + "-item-" + itemName);
    string tempItemName = m_assetStrTable.GetString(m_configPrefix + "-item-" + itemName);
    if (tempItemName == "null")
      m_itemDisplayNames[m_itemDisplayNames.size()] = "";
    else
      m_itemDisplayNames[m_itemDisplayNames.size()] = tempItemName;

    ResetButtons();
  }

  // Resets buttons such that all are false and only the current one is set (which is how radio buttons are
  // generally meant to behave)
  public void ResetButtons(void)
  {
    if ((m_currentSelection < 0)  or  (m_currentSelection >= m_itemSettings.size()))
    {
      m_currentSelection = 0; // reset to 0 (the first one) as a default
      return;
    }

    int i;
    for (i = 0; i < m_itemSettings.size(); i++)
      m_itemSettings[i] = false;

    m_itemSettings[m_currentSelection] = true; // we only have one button set and that is the current one!
  }

  //
  // ??
  //
  public HTMLPropertyHandler GetSelectedSubHandler(void)
  {
    return GetItemSubHandler(m_currentSelection);
  }

  //
  // ??
  //
  string GetHTMLButton(string urlString, bool setting)
  {
    return HTMLWindow.RadioButton(urlString, setting);
  }


  //
  // Property handler methods
  //

  public void SetPropertyValue(string propertyID, PropertyValue value)
  {
    string property = PropStripPrefix(propertyID, "");
    if (TrainUtil.GetUpTo(property, "/") == "itemSetting")
    {
      int itemIndex = Str.ToInt(TrainUtil.GetAfter(property, "/"));
      m_itemSettings[itemIndex] = !m_itemSettings[itemIndex];
      m_currentSelection = itemIndex;
      ResetButtons();
      return;
    }

    inherited(propertyID, value);
  }
  
  public Soup GetProperties()
  {
    Soup soup = inherited();
    soup.SetNamedTag("RadioButtonGroupHandler.currentSelection", m_currentSelection);
    return soup;
  }

  public void SetProperties(Soup soup)
  {
    inherited(soup);
    m_currentSelection = soup.GetNamedTagAsInt("RadioButtonGroupHandler.currentSelection", m_currentSelection);
  }

};



//! A config asset handler that manages a property item that can be one of many possible enumerated values.
//
// This class manages a single property that can be one of any number of possible enumerated values as
// specified in the host asset's string table.  This particular property has the name of <m "itemName">
// but what range of values it can be is entirely dependent on the configuration.
//
// For this class to work properly, the string table requirements are:
//
// {[ String Name                      | Description                                     ]
//  [ "<config-prefix>-html-property"  | HTML code to present this handler's current setting in.  String
//                                       parameter $0 is where the item is inserted wrapped as a URL.     ]
//  [ "<config-prefix>-blank-string"   | Blank string for when there is no chosen item.  ]
//  [  |  ]
//  [ "<config-prefix>-item$N"         | Reference name of the Nth item.  The item count must start from 0
//                                       and increase in a linear order.  This handler can determine how
//                                       many items there are to enumerate and will stop when the linear
//                                       order ends.  There must be a be string table entry for each item
//                                       entry like this.  ]
//  [ "&lt;reference-name $N&gt;"      | Full user-friendly name for item $N.  The full name of this string
//                                       table entry is defined by the reference string which is specified
//                                       in the <m "<config-prefix>-item$N"> string.  See the example below
//                                       if this is getting too confusing ;)  ]
//  [  |  ]
//  [ "<config-prefix>-html-prefix"    | HTML code inserted at the start of the properties page.  ]
//  [ "<config-prefix>-html-sufix"     | HTML code inserted at the end of the properties page.    ]}
//
// For example, here are the string table items from the <l astSrcRuleMultJuncCheck  Multiple Junction Align Check>
// rule where the config prefix is <m "multi-junc-setting">:
//
// {[ String Name                         | Contents                      ]
//  [ "multi-junc-setting-html-property"  | "Junction state is: $0"       ]
//  [ "multi-junc-setting-blank-string"   | "&lt;i&gt;click to select&lt;/i&gt;"  ]
//  [  |  ]
//  [ "multi-junc-setting-item0"          | "multi-junc-setting-left"     ]
//  [ "multi-junc-setting-item1"          | "multi-junc-setting-center"   ]
//  [ "multi-junc-setting-item2"          | "multi-junc-setting-right"    ]
//  [ "multi-junc-setting-item3"          | "multi-junc-setting-any"      ]
//  [  |  ]
//  [ "multi-junc-setting-left"           | "Left"                        ]
//  [ "multi-junc-setting-center"         | "Center"                      ]
//  [ "multi-junc-setting-right"          | "Right"                       ]
//  [ "multi-junc-setting-any"            | "Any"                         ]
//  [  |  ]
//  [ "multi-junc-setting-html-prefix"    | "&lt;font color=#000000&gt;"  ]
//  [ "multi-junc-setting-html-sufix"     | "&lt;/font&gt;"               ]}
//
// In this particular case, an enumeration of 4 possible junction states is defined so the handler
// provides a way to select what state a junction should be in.
//
// The EnumeratedPropertyHandler class is also used by the following rules:
//  - <l astSrcRuleSetCamera         Set Camera>
//  - <l astSrcRuleSetJuncs          Set Junctions>
//  - <l astSrcRuleShowHideHUDPanel  Show/Hide HUD Panel>
//  - <l astSrcRuleWaitCamera        Wait for Camera View Mode>
//
// Useful interface methods provided with this class are:
//  - public int       <b GetItemIndex>  () 
//  - public int       <b GetItemCount>  ()
//  - public string    <b GetItem>       ()
//  - public string    <b GetItem>       (int index)
//  - public string[]  <b GetItems>      ()
//  - public string    <b GetItemFull>   ()
//  - public bool      <b IsEnumSet>     ()
//
// Note:
//     EnumeratedPropertyHandler was mainly written as a utility class for use in the TRS2006 session rules.
//     It is not part of the core %Trainz API and is not fully documented.  Those who are interested in how 
//     this class works can see all the full implementation in the <b \Trainz\scripts\ListItemPropertyHandler.gs>
//     script file.
//
// See Also:
//     EnumeratedMultiPropertyHandler, EnumeratedGameObjectHandler, EnumeratedAssetHandler,
//     AssetCheckListHandler, CheckListPropertyHandler, GenericBoolHandler, GenericStringHandler,
//     GenericListHandler, RadioButtonListHandler, RadioButtonGroupHandler
//
class EnumeratedPropertyHandler isclass ConfigAssetHandler
{
  int      m_itemIndex = -1;
  string[] m_itemsList = new string[0];


  //
  // Public method definitions
  //

  public void Init(Asset asset, string newConfigPrefix);
  public void Init(Asset asset, string newConfigPrefix, int enumSize);

  public void Init(Asset asset, string newConfigPrefix, PropertyValue[] extraValues);


  //@ Document me!
  //
  // Returns:
  //     ??
  //
  public int      GetItemIndex() { return m_itemIndex; }

  //@ Document me!
  //
  // Returns:
  //     ??
  //
  public int      GetItemCount() { return m_itemsList.size(); }

  //@ Document me!
  //
  // Returns:
  //     ??
  //
  public string   GetItem(void);

  //@ Document me!
  //
  // Returns:
  //     ??
  //
  public string[] GetItems(void) { return m_itemsList; }

  //@ Document me!
  //
  // Returns:
  //     ??
  //
  public bool IsEnumSet(void) { return (m_itemIndex >= 0)  and  (m_itemIndex < m_itemsList.size()); }


  //
  // Method implementations
  //

  //
  // Initialization method. 
  //
  // It's the responsibility of the user to call it with the asset as this handler assumes you know
  // what you are doing!  Don't do anything else with the handler until has been initialized with 
  // this method.
  //
  public void Init(Asset asset, string newConfigPrefix)
  {
    inherited(asset, newConfigPrefix);

    Soup englishStrTable = asset.GetConfigSoup().GetNamedSoup("string-table");

    // initialize the enumeration based on the string-table of provided asset (if not already done)
    //  - only do this if this object has already had its enum initialised
    if (!m_itemsList.size())
    {
      int i = 0;
      while(true)
      {
        string itemString = englishStrTable.GetNamedTag(m_configPrefix + "-item" + i);
        if (!itemString.size())
          break;

        m_itemsList[i++] = itemString;
      }
    }
    else
    {
      int i;
      for (i = 0; i < m_itemsList.size(); i++)
        m_itemsList[i] = englishStrTable.GetNamedTag(m_configPrefix + "-item" + i);
    }

  }

  public void Init(Asset asset, string newConfigPrefix, PropertyValue[] extraValues)
  {
    InitBasics(asset, newConfigPrefix);
  }


  //
  // Alternative initialization method that gets enumerated values based. Be careful if using a derived-class
  // with this method though.
  //
  public void Init(Asset asset, string newConfigPrefix, int enumSize)
  {
    if (enumSize)
      m_itemsList = new string[enumSize];

    Init(asset, newConfigPrefix);
  }


  //
  // Gets the current item as directed by the index setting.
  // If the current index is invalid, a string with the text of "null" is returned.
  //
  public string GetItem(void)
  { 
    if ((m_itemIndex < 0)  or  (m_itemIndex >= m_itemsList.size()))
      return "null";

    return m_itemsList[m_itemIndex];
  }

  //
  // Gets the item by index, empty string on failure
  //
  public string GetItem(int index)
  { 
    if ((index < 0)  or  (index >= m_itemsList.size()))
      return "";

    return m_itemsList[index];
  }

  //@ Document me.
  //
  // Gets the full display name of the current item.
  //
  public string GetItemFull(void)
  {
    if ((m_itemIndex < 0)  or  (m_itemIndex >= m_itemsList.size()))
      return m_assetStrTable.GetString(m_configPrefix + "-blank-string");

    return m_assetStrTable.GetString(m_itemsList[m_itemIndex]);
  }


  //
  // Property Handler method implementations
  //

  //
  // Gets a HTML page describing this handler's properties.
  //
  // This implementation assumes the asset has a string table entry named "<prefix>-html-property"
  // with one string paramters ($0).  It will place a URL for the item name into the solo string 
  // parameter ($0).  This URL is usable with the rest of the property methods in this class.
  //
  // This is intended as a minimal default implementation.  In most cases, you would probably want 
  // to override this method and do your own thing.
  //
  public string GetDescriptionHTML(void)
  {
    string htmlPage = m_assetStrTable.GetString1(m_configPrefix + "-html-property",
                                                 HREF("itemName") + GetItemFull() + "</a>");
    return m_htmlPrefix + htmlPage + m_htmlSufix;
  }

  //
  // Gets the type for named property.
  //
  public string GetPropertyType(string propertyID)
  {
    if (PropStripPrefix(propertyID, "") == "itemName")
      return "list";

    return inherited(propertyID);
  }

  //
  // Sets value of the named property.
  //
  public void SetPropertyValue(string propertyID, PropertyValue value)
  {
    if (PropStripPrefix(propertyID, "") == "itemName")
      m_itemIndex = value.GetIndex();
    else
      inherited(propertyID, value);
  }

  //
  // Gets list of elements to choose from for the named property
  //
  public string[] GetPropertyElementList(string propertyID)
  {
    if (PropStripPrefix(propertyID, "") == "itemName")
    {
      string[] retStrList = new string[0];
      int i;
      for (i = 0; i < m_itemsList.size(); i++) 
        retStrList[i] = m_assetStrTable.GetString(m_itemsList[i]);

      return retStrList;
    }

    return inherited(propertyID);
  }

  public string GetPropertyName(string propertyID)
  {
    if (PropStripPrefix(propertyID, "") == "itemName")
      return m_assetStrTable.GetString(m_configPrefix + "-name-itemName");

    return inherited(propertyID);
  }

  public string GetPropertyDescription(string propertyID)
  {
    if (PropStripPrefix(propertyID, "") == "itemName")
      return m_assetStrTable.GetString(m_configPrefix + "-desc-itemName");

    return inherited(propertyID);
  }

  //
  // Return properties of this object in a soup
  //
  public Soup GetProperties()
  {
    Soup soup = inherited();
    soup.SetNamedTag("EnumeratedPropertyHandler.itemIndex", m_itemIndex);

    // always save the items to the soup
    Soup itemsListSoup = Constructors.NewSoup();
    int i;
    for (i = 0; i < m_itemsList.size(); i++)
      itemsListSoup.SetNamedTag((string)i, m_itemsList[i]);

    soup.SetNamedSoup("EnumeratedPropertyHandler.itemsList", itemsListSoup);

    return soup;
  }

  //
  // Initialize this object from the given properties soup
  //
  public void SetProperties(Soup soup)
  {
    inherited(soup);
    m_itemIndex = soup.GetNamedTagAsInt("EnumeratedPropertyHandler.itemIndex", -1);

    // we only do this if the itemsList stuff hasn't already been initialized by Init()
    if (!m_itemsList.size())
    {
      Soup itemsListSoup = soup.GetNamedSoup("EnumeratedPropertyHandler.itemsList");
      m_itemsList = new string[0]; // trash and reset
      int i;
      for (i = 0; i < itemsListSoup.CountTags(); i++)
        m_itemsList[i] = itemsListSoup.GetNamedTag((string)i);
    }
  }

};



//! Config asset handler that manages an enumerated property where each value of the enumeration has its own set of enumerated sub items.
//
// This class inherits the enumerated property functionality from EnumeratedPropertyHandler and extends it
// such that each item in the enumeration (the major type) has its own enumerated collection of sub-items.
// The currently selected item from the major type will determine what range of items will be available
// to be selected for the sub-type.
//
// The config string table requirements for this class are much trickier than most of the other config asset 
// handler classes, so refer to the example listed further below if this initial table is too confusing.
//
// {[ String Name                         | Description                                                      ]
//  [ "<config-prefix>-html-property"     | HTML text for presenting this handler's settings which has two
//                                          string parameters, one for type ($0) and the other for the 
//                                          sub-type ($1).  These string parameters can be placed in any
//                                          order so you can have the major type property first or the 
//                                          sub-type property first.      ]
//  [ "<config-prefix>-blank-string"      | Blank string for when a major/sub type isn't selected.           ]
//  [ "<config-prefix>-empty-sub-list"    | Blank string for when a major type isn't selected and user tries
//                                          to select a sub type anyway.  ]
//  [  |  ]
//  [ "<config-prefix>-name-itemName"     | Display name for major type (in general - non specific).     ]
//  [ "<config-prefix>-desc-itemName"     | Tooltip description for major type.                          ]
//  [  |  ]
//  [ "<config-prefix>-name-subName"      | Display name for minor type (in general - non specific).     ]
//  [ "<config-prefix>-desc-subName"      | Tooltip description for minor type.  Applies to all sub type
//                                          enumerations, so use something general and non-sepcific.     ]
//  [  |  ]
//  [ "<config prefix>-item$N"            | Reference name of the Nth item of the major type.  The item count
//                                          must start from 0 and increase in a linear order.  There must be
//                                          a string table entry for each item entry like this.       ]
//  [ "&lt;reference-name $N&gt;"         | Full user-friendly name for item $N of the major type.  The full
//                                          name of this string table entry is defined by the reference name
//                                          as specified in the <m "<config-prefix>-item$N"> string.  ]
//  [  |  ]
//  [ "&lt;reference-name $N&gt;-item$X"  | Reference name of the $Xth sub item for the $Nth item of the 
//                                          major type.  As with the major type items, sub items are defined
//                                          in a linear order.  The must be an enumerated set of sub items
//                                          defined for each major type item.  Each enumerated sub-type 
//                                          collection can have a different amount of items.  ]
//  [ "&lt;reference-name $N&gt;-tiem$X"  | Full user friendly name for the sub-item specified by the
//                                          <m "&lt;reference-name $N&gt;-item$X"> string.  This will be the 
//                                          readable name for the $Xth sub-item of the $Nth major type.  ]
//  [  |  ]
//  [ "<config-prefix>-html-prefix"       | HTML code inserted at the start of the properties page.  ]
//  [ "<config-prefix>-html-sufix"        | HTML code inserted at the end of the properties page.    ]}
//
// As an example, consider the <l astSrcRuleWaitHUDIconClick  Wait For Click on HUD Icon> rule that allows the
// user to select an particular icon from one of the HUD panels.  We have several HUD panels, each with its
// own unique set of icons and which fits in with this handler nicely.  The handler's major type is an 
// enumeration of the HUD panels while each panel item has its own collection of icons enumerated as 
// sub-types.  With a config prefix of <m "wait-panel-icon">, the string table elements for the 
// <l astSrcRuleWaitHUDIconClick  Wait For Click on HUD Icon> rule are:
//
// {[ String Name                       | Contents                                                ]
//  [ "wait-panel-icon-html-property"   | "Wait for a click on the $1 icon on the $0 HUD panel."  ]
//  [ "wait-panel-icon-blank-string"    | "&lt;i&gt;click to select&lt;/i&gt;"                    ]
//  [ "wait-panel-icon-empty-sub-list"  | "Choose a HUD panel first!"                             ]
//  [ "wait-panel-icon-html-prefix"     | "&lt;table border='0' cellspacing='0' cellpadding='0'&gt;&lt;tr&gt;&lt;td width=4&gt;&lt;/td&gt;&lt;td&gt;&lt;font color=#000000&gt;"  ]
//  [ "wait-panel-icon-html-sufix"      | "&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;"     ]
//  [  |  ]
//  [ "wait-panel-icon-name-itemname"   | "HUD Panel"                    ]
//  [ "wait-panel-icon-desc-itemname"   | "HUD Panel to flash icon on"   ]
//  [ "wait-panel-icon-name-subitem"    | "Icon"                         ]
//  [ "wait-panel-icon-desc-subitem"    | "Icon to wait for a click on"  ]
//  [  |  ]
//  [ "wait-panel-icon-item0"           | "panel-bottom-right"     ]
//  [ "wait-panel-icon-item1"           | "panel-camera-controls"  ]
//  [ "wait-panel-icon-item2"           | "panel-dcc-controls"     ]
//  [ "panel-bottom-right"              | "Bottom Right Menu"      ]
//  [ "panel-camera-controls"           | "Camera Controls"        ]
//  [ "panel-dcc-controls"              | "DCC Controls"           ]
//  [  |  ]
//  [ "panel-bottom-right-item0"                 | "btn/message"       ]
//  [ "panel-bottom-right-item1"                 | "btn/minimap"       ]
//  [ "panel-bottom-right-item2"                 | "btn/commodities"   ]
//  [ "panel-bottom-right-item3"                 | "btn/decouple"      ]
//  [ "panel-bottom-right-item4"                 | "btn/waybills"      ]
//  [ "panel-bottom-right-item5"                 | "btn/schedule"      ]
//  [ "panel-bottom-right-item6"                 | "btn/help"          ]
//  [ "panel-bottom-right-item-btn/message"      | "Messages"          ]
//  [ "panel-bottom-right-item-btn/minimap"      | "Map"               ]
//  [ "panel-bottom-right-item-btn/commodities"  | "Commodities"       ]
//  [ "panel-bottom-right-item-btn/decouple"     | "Decoupling"        ]
//  [ "panel-bottom-right-item-btn/waybills"     | "Waybill"           ]
//  [ "panel-bottom-right-item-btn/schedule"     | "View Schedule"     ]
//  [ "panel-bottom-right-item-btn/help"         | "View Driver Help"  ]
//  [  |  ]
//  [ "panel-camera-controls-item0"              | "view-0/"           ]
//  [ "panel-camera-controls-item1"              | "view-1/"           ]
//  [ "panel-camera-controls-item2"              | "view-2/"           ]
//  [ "panel-camera-controls-item3"              | "view-3/"           ]
//  [ "panel-camera-controls-item-view-0/"       | "Cab View"          ]
//  [ "panel-camera-controls-item-view-1/"       | "External View"     ]
//  [ "panel-camera-controls-item-view-2/"       | "Tracking View"     ]
//  [ "panel-camera-controls-item-view-3/"       | "Free Roaming"      ]
//  [  |  ]
//  [ "panel-dcc-controls-item0"                 | "dial/dcc"          ]
//  [ "panel-dcc-controls-item1"                 | "button/pants"      ]
//  [ "panel-dcc-controls-item2"                 | "button/lights"     ]
//  [ "panel-dcc-controls-item3"                 | "button/horn"       ]
//  [ "panel-dcc-controls-item4"                 | "button/stop"       ]
//  [ "panel-dcc-controls-item-dial/dcc"         | "Speed Dial"        ]
//  [ "panel-dcc-controls-item-button/pants"     | "Pantographs"       ]
//  [ "panel-dcc-controls-item-button/lights"    | "Lights"            ]
//  [ "panel-dcc-controls-item-button/horn"      | "Horn"              ]
//  [ "panel-dcc-controls-item-button/stop"      | "Stop"              ]}
//
// Pay particular attention to how the enumerations of sub-items are defined for each item in the major type
// enumeration.
//
// The EnumeratedMultiPropertyHandler class is also used by the <l astSrcRuleFlashHUDIcon  Flash HUD Icon> rule.
//
// Useful interface methods provided with this class are:
//  - public string  <b GetSubItem>      ()
//  - public string  <b GetSubItemFull>  ()
//  - public bool    <b IsSubEnumSet>    ()
//
// As well as that, the following methods inherited from EnumeratedPropertyHandler are also applicable to this class:
//  - public int       <b GetItemIndex>  () 
//  - public int       <b GetItemCount>  ()
//  - public string    <b GetItem>       ()
//  - public string    <b GetItem>       (int index)
//  - public string[]  <b GetItems>      ()
//  - public string    <b GetItemFull>   ()
//  - public bool      <b IsEnumSet>     ()
//
// Note:
//     EnumeratedMultiPropertyHandler was mainly written as a utility class for use in the TRS2006 session 
//     rules.  It is not part of the core %Trainz API and is not fully documented.  Those who are interested
//     in how this class works can see all the full implementation in the 
//     <b \Trainz\scripts\ListItemPropertyHandler.gs> script file.
//
// See Also:
//     EnumeratedPropertyHandler, EnumeratedGameObjectHandler, EnumeratedAssetHandler, AssetCheckListHandler,
//     CheckListPropertyHandler, GenericBoolHandler, GenericStringHandler, GenericListHandler,
//     RadioButtonListHandler, RadioButtonGroupHandler
//
class EnumeratedMultiPropertyHandler isclass EnumeratedPropertyHandler
{
  int m_subItemIndex = -1;
  //int[] m_subItemsCount = new int[0];

  //
  // Method definitions
  //

  public void Init(Asset asset, string newConfigPrefix);


  //@ Gets the currently selected sub items index.
  //
  // Returns:
  //     ??
  //
  public int GetSubItemIndex(void) { return m_subItemIndex; }


  //@ Gets the currently selected sub item reference name as a string.
  //
  // Returns:
  //     ??
  //
  public string GetSubItem(void);
  
  //@ Gets the full descruiptive text of the currently selected sub-item.
  //
  // Returns:
  //     ??
  //
  public string GetSubItemFull(void);

  //@ Determines if a sub-item is selected for the currently selected.
  //
  // Returns:
  //     ??
  //
  public bool IsSubEnumSet(void) { return (IsEnumSet()  and  GetSubItem().size()); }


  //
  // Method implementations
  //

  public void Init(Asset asset, string newConfigPrefix)
  {
    inherited(asset, newConfigPrefix);

    //----- experimental ---------------------------------------------------
    /*Interface.Log("### EnumeratedMultiPropertyHandler.Init> I was called, generate list of sub-items...");
    if (m_itemsList.size())
    {
      Interface.Log("     -> List of " + m_itemsList.size() + " items is ready, figure out the sub-items now!");
      m_subItemsCount = new int[m_itemsList.size()];
      int i;
      for (i = 0; i < m_subItemsCount.size(); i++)
      {
        Interface.Log("Under construction...");
      }
    }*/
    //----------------------------------------------------------------------
  }

  //
  // Gets the string that identifies the reference name of the currently selected sub-item.
  //
  // This string should be of the format: "?"
  // In addition to that, your asset's string table must have a string table entry of that n
  //
  public string GetSubItem(void) 
  {
    if (m_subItemIndex < 0)
      return "";

    string subItemRef = GetItem() +  "-item" + (string)m_subItemIndex;
    return m_assetStrTable.GetString(subItemRef);
  }

  public string GetSubItemFull(void) 
  {
    if (m_subItemIndex < 0)
      return m_assetStrTable.GetString(m_configPrefix + "-blank-string");

    return m_assetStrTable.GetString(GetItem() + "-item-" + GetSubItem());
  }


  //
  // Properties methods
  //

  //
  // Gets a HTML page describing this handler's properties.
  //
  // This implementation assumes the asset has a string table entry named "<prefix>-html-property"
  // with two string paramters ($0 and $1).  It will place a URL for the item name into the first 
  // string paramater ($0) and the sub item's URL in the second one ($1).  These URLs are usable 
  // with the rest of the property methods in this class.
  //
  // This is intended as a minimal default implementation.  In most cases, you would probably want
  // to override this method and do your own thing.
  //
  public string GetDescriptionHTML(void)
  {
    string htmlPage = m_assetStrTable.GetString2(m_configPrefix + "-html-property",
                                                 HREF("itemName") + GetItemFull() + "</a>",
                                                 HREF("subItem") + GetSubItemFull() + "</a>");
    return m_htmlPrefix + htmlPage + m_htmlSufix;
  }

  //
  // Returns "list" for the "subItem" property, "list" for the "itemName" property as well via 
  // calling the parent method.
  //
  public string GetPropertyType(string propertyID)
  {
    if (PropStripPrefix(propertyID, "") == "subItem")
      return "list";

    return inherited(propertyID);
  }

  //
  // Sets the value of the named property.
  //
  public void SetPropertyValue(string propertyID, PropertyValue value)
  {
    string property = PropStripPrefix(propertyID, "");

    // this was in parent class method, but we need to reset the subitem whenever the item is reset so
    // inherit won't be used.
    if (property == "itemName")
    {
      int newItemIndex = value.GetIndex();
      if (m_itemIndex != newItemIndex) // reset sub-item if item  setting is different
        m_subItemIndex = -1;

      m_itemIndex = newItemIndex;
    }
    else if (property == "subItem")
    {
      int newIndex = value.GetIndex();
      if (m_itemIndex < 0) // if no item is selected, we leave this one blank as well
        m_subItemIndex = -1;
      else
        m_subItemIndex = newIndex;
    }
  }

  //
  // Gets list of elements to choose from for the named property
  //
  public string[] GetPropertyElementList(string propertyID)
  {
    if (PropStripPrefix(propertyID, "") == "subItem")
    {
      string[] retStrList = new string[0];

      // if an item isn't selected, we return a list saying to choose an item first
      if (m_itemIndex < 0)
      {
        retStrList[0] = m_assetStrTable.GetString(m_configPrefix + "-empty-sub-list");
        return retStrList;
      }

      int i = 0;
      while (true)
      {
        string retrievedSubItem = m_assetStrTable.GetString(GetItem() + "-item" + (string)i);
        string actualItem = m_assetStrTable.GetString(GetItem() + "-item-" + retrievedSubItem);

        if (actualItem  and  actualItem.size())
          retStrList[i++] = actualItem;
        else
          break;
      }
      return retStrList;
    }

    return inherited(propertyID);
  }

  public string GetPropertyName(string propertyID)
  {
    if (PropStripPrefix(propertyID, "") == "subItem")
      return m_assetStrTable.GetString(m_configPrefix + "-name-subItem");

    return inherited(propertyID);
  }

  public string GetPropertyDescription(string propertyID)
  {
    if (PropStripPrefix(propertyID, "") == "subItem")
      return m_assetStrTable.GetString(m_configPrefix + "-desc-subItem");

    return inherited(propertyID);
  }


  //
  // Return properties of this object in a soup
  //
  public Soup GetProperties()
  {
    Soup soup = inherited();
    soup.SetNamedTag("EnumeratedMultiPropertyHandler.subItemIndex", m_subItemIndex);
    return soup;
  }

  //
  // Initialize this object from the given properties soup
  //
  public void SetProperties(Soup soup)
  {
    m_subItemIndex = soup.GetNamedTagAsInt("EnumeratedMultiPropertyHandler.subItemIndex");
    inherited(soup);
  }

};



//! A config asset handler that manages a property item that can be one of any installed Asset of a particular kind/type.
//
// This class manages a single property that can be selected from an enumeration of installed assets of
// particular kind/type.
//
// For this class to work properly, the following string table entries are required:
//
// {[ String Name                            | Description                                                     ]
//  [ "<config-prefix>-asset-type"           | Type/kind of asset to enumerate. will be overridden by category 
//                                             string if provided.  ]
//  [ "<config-prefix>-category-filter"      | Asset category string to search for.  ]
//  [ "<config-prefix>-blank-string"         | Blank string to display when no asset is selected.              ]
//  [ "<config-prefix>-asset-html-property"  | String where chosen asset is displayed.  This string must have
//                                             a parameter of $0 for the asset selection URL to be placed in.  ]
//  [  |  ]
//  [ "<config-prefix>-name-selectedAsset"   | Text name to describe the type of asset.  This will be displayed as
//                                             the title name in the list selection box where the asset is chosen.  ]
//  [ "<config-prefix>-desc-selectedAsset"   |  Description text of asset type being selected.  Will appear as a
//                                              tooltip in the list selection box.  ]
//  [  |  ]
//  [ "<config-prefix>-html-prefix"          | HTML code inserted at the start of the properties page.  ]
//  [ "<config-prefix>-html-sufix"           | HTML code inserted at the end of the properties page.    ]}
//
// Note:
//     If your asset uses this handler, keep in mind it might be run on other %Trainz installations that may
//     not have the asset the handler has been saved with installed.  This is a situation you should always
//     allow for.
//
// The EnumeratedAssetHandler class is used by the <l astSrcRuleDrivCmdChk  Driver Command Check> rule with
// a config prefix of <m "driver-char"> as shown in the table below:
//
// {[ String Name                        | Contents             ]
//  [ "driver-char-asset-type"           | "drivercharacter"    ]
//  [ "driver-char-asset-html-property"  | "Driver character to watch the commands list of: $0"  ]
//  [ "driver-char-blank-string"         | "&lt;i&gt;click to select&lt;/i&gt;"  ]
//  [  |  ]
//  [ "driver-char-name-assetname"       | "Drivers"            ]
//  [ "driver-char-desc-assetname"       | "Driver Characters"  ]
//  [  |  ]
//  [ "driver-char-html-prefix"          | "&lt;table cellpadding=0 cellspacing=0&gt;&lt;tr&gt;&lt;td width=3&gt;&lt;/td&gt;&lt;td&gt;&lt;font color=#000000&gt;"  ]
//  [ "driver-char-html-sufix"           | "&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;"  ]}
//
// Note:
//     EnumeratedAssetHandler was mainly written as a utility class for use in the TRS2006 session rules.  It
//     is not part of the core %Trainz API and is not fully documented.  Those who are interested in how this
//     class works can see all the full implementation in the <b \Trainz\scripts\ListItemPropertyHandler.gs>
//     script file.
//
// See Also:
//     EnumeratedPropertyHandler, EnumeratedGameObjectHandler, EnumeratedMultiPropertyHandler,
//     AssetCheckListHandler, CheckListPropertyHandler, GenericBoolHandler, GenericStringHandler, 
//     GenericListHandler, RadioButtonListHandler, RadioButtonGroupHandler
//
class EnumeratedAssetHandler isclass ConfigAssetHandler
{
  string    m_assetType;        // The asset 'kind' for this handler
  string    m_categoryFilter;   // The category filter to search with
  Asset     m_selectedAsset;    // The asset that is currently selected, if any

  public void Init(Asset asset, string newConfigPrefix);

  public string GetAssetName(void);
  public Asset GetSelectedAssetRef(void) { return m_selectedAsset; }
  public void SetAsset(Asset newAsset) { m_selectedAsset = newAsset; }
  public void SetCategoryFilter(string newCategory) { m_categoryFilter = newCategory; }


  //=============================================================================
  // Name: Init
  // Desc: Initialises this handler from an asset config and a tag prefix
  //=============================================================================
  public void Init(Asset asset, string newConfigPrefix)
  {
    inherited(asset, newConfigPrefix);

    m_categoryFilter = m_assetStrTable.GetString(m_configPrefix + "-category-filter");
    if (m_categoryFilter == "")
    {
      m_assetType = m_assetStrTable.GetString(m_configPrefix + "-asset-type");
      if (m_assetType == "")
      {
        Interface.Exception("EnumeratedAssetHandler.Init> No asset type or category filter provided");
        return;
      }

      // The use of asset type/kind is obsolete, convert it to a category string
      m_categoryFilter = TrainzAssetSearch.GetCategoryStringForAssetKind(m_assetType);
      if (m_categoryFilter == "")
      {
        Interface.Exception("EnumeratedAssetHandler.Init> Unknown/invalid asset kind '" + m_assetType + "'");
        return;
      }
    }

  }


  //=============================================================================
  // Name: GetAssetName
  // Desc: Returns the localised name of any selected asset
  //=============================================================================
  public string GetAssetName()
  {
    if (!m_selectedAsset)
      return m_assetStrTable.GetString(m_configPrefix + "-blank-string");

    return m_selectedAsset.GetLocalisedName();
  }


  // Obsolete, do not use
  public obsolete Asset GetAssetByIndex(int index)
  {
    Interface.WarnObsolete("EnumeratedAssetHandler.GetAssetByIndex> Obsolete function");
    return null;
  }

  // Obsolete, do not use
  public obsolete Asset GetAssetByName(string assetName)
  {
    Interface.WarnObsolete("EnumeratedAssetHandler.GetAssetByName> Obsolete/unsafe function");
    return null;
  }

  // Obsolete, do not use
  public string GetAssetType(void) { return m_assetType; }

  // Obsolete, do not use
  public obsolete void SetAssetType(string newType)
  {
    m_assetType = newType;

    // The use of asset type/kind is obsolete, convert it to a category string
    m_categoryFilter = TrainzAssetSearch.GetCategoryStringForAssetKind(m_assetType);
    if (m_categoryFilter == "")
    {
      Interface.Exception("EnumeratedAssetHandler.SetAssetType> Unknown/invalid asset kind '" + m_assetType + "'");
      return;
    }
  }


  //=============================================================================
  // Name: GetDescriptionHTML
  // Desc: Returns a HTML description of this asset property for display in game.
  //=============================================================================
  public string GetDescriptionHTML(void)
  {
    string htmlPage = m_assetStrTable.GetString1(m_configPrefix + "-asset-html-property", 
                                                 HREF("assetName") + GetAssetName() + "</a>");
    return m_htmlPrefix + htmlPage + m_htmlSufix;
  }


  //=============================================================================
  // Name: GetPropertyType
  // Desc: Gets the type for the property ID passed
  //=============================================================================
  public string GetPropertyType(string propertyID)
  {
    if (PropStripPrefix(propertyID, "") == "assetName")
      return "asset-list," + m_categoryFilter;

    return inherited(propertyID);
  }


  //=============================================================================
  // Name: GetPropertyValue
  // Desc: Returns the value of the property with the ID passed
  //=============================================================================
  public string GetPropertyValue(string propertyID)
  {
    if (PropStripPrefix(propertyID, "") == "assetName")
      return GetAssetName();

    return inherited(propertyID);
  }


  //=============================================================================
  // Name: GetPropertyName
  // Desc: Returns a human readable name for the property with the ID passed
  //=============================================================================
  public string GetPropertyName(string propertyID)
  {
    if (PropStripPrefix(propertyID, "") == "assetName")
      return m_assetStrTable.GetString(m_configPrefix + "-name-assetName");

    return inherited(propertyID);
  }


  //=============================================================================
  // Name: GetPropertyDescription
  // Desc: Returns a localised description for the property with the ID passed
  //=============================================================================
  public string GetPropertyDescription(string propertyID)
  {
    if (PropStripPrefix(propertyID, "") == "assetName")
      return m_assetStrTable.GetString(m_configPrefix + "-desc-assetName");

    return inherited(propertyID);
  }


  //=============================================================================
  // Name: SetPropertyValue
  // Desc: Sets the value of a property
  //=============================================================================
  public void SetPropertyValue(string propertyID, PropertyValue value)
  {
    if (PropStripPrefix(propertyID, "") == "assetName")
    {
      m_selectedAsset = cast<Asset>(value.AsObject());
      return;
    }

    inherited(propertyID, value);
  }


  //=============================================================================
  // Name: GetProperties
  // Desc: Return properties of this object in a soup, for save/load support
  //=============================================================================
  public Soup GetProperties()
  {
    Soup soup = inherited();

    soup.SetNamedTag("EnumeratedAssetHandler.category-filter", m_categoryFilter);
    soup.SetNamedTag("EnumeratedAssetHandler.assetType", m_assetType);
    if (m_selectedAsset)
      soup.SetNamedTag("EnumeratedAssetHandler.selectedAsset", m_selectedAsset.GetKUID());

    return soup;
  }


  //=============================================================================
  // Name: GetProperties
  // Desc: Initialises this handler from the soup passed, for save/load support
  //=============================================================================
  public void SetProperties(Soup soup)
  {
    inherited(soup);

    // Only load asset type if it isn't already set, as Init may have loaded a
    // newer value from the host string-table
    if (m_assetType == "" and m_categoryFilter == "")
    {
      m_categoryFilter = soup.GetNamedTag("EnumeratedAssetHandler.category-filter");
      m_assetType = soup.GetNamedTag("EnumeratedAssetHandler.assetType");

      if (m_assetType != "" and m_categoryFilter == "")
        m_categoryFilter = TrainzAssetSearch.GetCategoryStringForAssetKind(m_assetType);
    }

    KUID selectedAssetKUID = soup.GetNamedTagAsKUID("EnumeratedAssetHandler.selectedAsset");
    if (selectedAssetKUID)
      m_selectedAsset = World.FindAsset(selectedAssetKUID);
    else
      m_selectedAsset = null;
  }

};



//! A config asset handler that manages a property item that can be any one of an enumeration of game objects of a particular type.
//
// This class manages a single property that can be selected from an enumeration of game objects of a 
// particular kind/type.
//
// For this class to work properly, the following string table entries are required:
//
// {[ String Name                             | Description                                                         ]
//  [ "<config-prefix>-object-type"           | Type of game object this handler is to deal with.  Allowed types
//                                              are <m "behavior">, <m "industry">, <m "junction">, <m "signal">,
//                                              <m "trackmark">, <m "traincar"> and <m "trigger">.                  ]
//  [ "<config-prefix>-object-html-property"  | HTML code to present this property handler in.  Parameter $0 is
//                                              where current game object will be inserted with a hyperlink.        ]
//  [ "<config-prefix>-blank-string"          | Blank string text to use as a hyperlink for when no game object
//                                              is currently selected. This string <bi MUST> be included, otherwise 
//                                              there will be nothing to click on to select an actual game object!  ]
//  [  |  ]
//  [ "<config-prefix>-name-gameObjectName"   | Readable name for game object (title for the list selection box).   ]
//  [ "<config-prefix>-desc-gameObjectName"   |  Description of game object name (tool-tip in list selection box).  ]
//  [  |  ]
//  [ "<config-prefix>-html-prefix"           | HTML code inserted at the start of the properties page.  ]
//  [ "<config-prefix>-html-sufix"            | HTML code inserted at the end of the properties page.    ]}
//
// Note:
//     If your asset uses this handler, keep in mind it might be run on other %Trainz installations that may
//     not have the game object this handler has been saved present.  This is a situation you should always
//     allow for.
//
// The EnumeratedGameObjectHandler class is used by the <l astSrcRuleWaitCamera  Wait for Camera View Mode> 
// rule with a config prefix of <m "wait-object-target"> as shown in the table below:
//
// {[ String Name                                | Contents                              ]
//  [ "wait-object-target-object-type"           | "traincar"                            ]
//  [ "wait-object-target-object-html-property"  | "$0"                                  ]
//  [ "wait-object-target-blank-string"          | "&lt;i&gt;click to select&lt;/i&gt;"  ]
//  [  |  ]
//  [ "wait-object-target-name-gameobjectname"   | "Target Vehicle"                      ]
//  [ "wait-object-target-desc-gameobjectname"   | "Vehicle camera is to focus on"       ]
//  [  |  ]
//  [ "wait-object-target-html-prefix"           | "&lt;font color=#000000&gt;"          ]
//  [ "wait-object-target-html-sufix"            | "&lt;/font&gt;"                       ]}
//
// Useful interface methods provided with this class are:
//  - public string      <b GetObjectType>      ()
//  - public string      <b GetObjectName>      ()
//  - public string      <b GetObjectNameFull>  ()
//  - public GameObject  <b GetGameObject>      ()
//
// Note:
//     EnumeratedGameObjectHandler was mainly written as a utility class for use in the TRS2006 session rules.
//     It is not part of the core %Trainz API and is not fully documented.  Those who are interested in how this
//     class works can see all the full implementation in the <b \Trainz\scripts\ListItemPropertyHandler.gs>
//     script file.
//
// See Also:
//     EnumeratedAssetHandler, EnumeratedPropertyHandler, EnumeratedMultiPropertyHandler,
//     AssetCheckListHandler, CheckListPropertyHandler, GenericBoolHandler, GenericStringHandler,
//     GenericListHandler, RadioButtonListHandler, RadioButtonGroupHandler
//
class EnumeratedGameObjectHandler isclass ConfigAssetHandler
{
  string m_gameObjectType = "";     // Type of game objects to target  (obsolete)
  string m_gameObjectName = "";     // Name of the currently selected game object (obsolete)

  string m_gameObjectCategory = ""; // Category code for target objects
  GameObjectID m_gameObjectID;      // The ID of the configured game object, if any
  string m_gameObjectLocName = "";  // The localised name of the current object


  public string GetObjectType(void) { return m_gameObjectType; }
  public string GetObjectName(void) { return m_gameObjectName; }
  public GameObjectID GetObjectID(void) { return m_gameObjectID; }

  void SetCategoryCodeForType();


  //=============================================================================
  // Name: Init
  // Desc: Initialise this config handler. This will set the asset and tag prefix
  //       then attempt to build an object list using the assets config file.
  //=============================================================================
  public void Init(Asset asset, string newConfigPrefix)
  {
    inherited(asset, newConfigPrefix); 

    m_gameObjectType = m_assetStrTable.GetString(m_configPrefix + "-object-type");
    Str.ToLower(m_gameObjectType);

    m_gameObjectCategory = m_assetStrTable.GetString(m_configPrefix + "-object-category");

    if (m_gameObjectType != "" and m_gameObjectCategory == "")
      SetCategoryCodeForType();

  }


  //=============================================================================
  // Name: GetObjectNameFull
  // Desc: Returns the localised display name of the current game object if set,
  //       or the host assets string-table entry for a blank value otherwise.
  //=============================================================================
  public string GetObjectNameFull(void)
  {
    if (m_gameObjectID and m_gameObjectLocName != "")
      return m_gameObjectLocName;

    return m_assetStrTable.GetString(m_configPrefix + "-blank-string");
  }


  //=============================================================================
  // Name: GetGameObject
  // Desc: Obsolete function, do not use. This will attempt to return the target
  //       game object if it's set, and currently loaded.
  //=============================================================================
  public obsolete GameObject GetGameObject(void)
  {
    if (m_gameObjectID)
    {
      GameObject gameObject = World.GetGameObjectByIDIfLoaded(m_gameObjectID);
      if (!gameObject)
        Interface.Log("# EnumeratedGameObjectRule.GetGameObject> ERROR: Unknown game object: " + m_gameObjectID.GetDebugString());

      return gameObject;
    }

    if (m_gameObjectName != "")
    {
      GameObject gameObject = Router.GetGameObject(m_gameObjectName);
      if (!gameObject)
        Interface.Log("# EnumeratedGameObjectRule.GetGameObject> ERROR: Unknown game object: " + m_gameObjectName);

      return gameObject;
    }

    Interface.Log("# EnumeratedGameObjectRule.GetGameObject> ERROR: No object configured");
    return null;
  }


  //=============================================================================
  // Name: GetDescriptionHTML
  // Desc: Returns the descriptive HTML for this property as currently configured
  //=============================================================================
  public string GetDescriptionHTML(void)
  {
    string htmlPage = m_assetStrTable.GetString1(m_configPrefix + "-object-html-property", 
                                                 HREF("gameObjectName") + GetObjectNameFull() + "</a>");
    return m_htmlPrefix + htmlPage + m_htmlSufix;
  }


  //=============================================================================
  // Name: GetPropertyType
  // Desc: PropertyObject interface to get a property type
  //=============================================================================
  public string GetPropertyType(string propertyID)
  {
    string propertyIDLocal = PropStripPrefix(propertyID, "");
    if (propertyIDLocal == "gameObjectName")
    {
      // Legacy support, and support for non-map-object types (e.g. session rules)
      if (m_gameObjectCategory == "RU" or m_gameObjectCategory == "")
        return "list,1";

      // Use the async map-object finder dialog if there's a category set
      return "map-object," + m_gameObjectCategory;
    }

    // Legacy support to allow list selection of a different object type. Should be avoided.
    if (propertyIDLocal == "gameObjectType")
      return "list,1";

    return inherited(propertyID);
  }


  //=============================================================================
  // Name: GetPropertyName
  //=============================================================================
  public string GetPropertyName(string propertyID)
  {
    if (PropStripPrefix(propertyID, "") == "gameObjectName")
      return m_assetStrTable.GetString(m_configPrefix + "-name-" + "gameObjectName");

    return inherited(propertyID);
  }


  //=============================================================================
  // Name: GetPropertyDescription
  //=============================================================================
  public string GetPropertyDescription(string propertyID)
  {
    if (PropStripPrefix(propertyID, "") == "gameObjectName")
      return m_assetStrTable.GetString(m_configPrefix + "-desc-" + "gameObjectName");

    return inherited(propertyID);
  }


  //=============================================================================
  // Name: SetPropertyValue
  // Desc: Sets a property value
  //=============================================================================
  public void SetPropertyValue(string propertyID, PropertyValue value)
  {
    string propertyIDLocal = PropStripPrefix(propertyID, "");
    if (propertyIDLocal == "gameObjectName")
    {
      if (value.GetType() == PropertyValue.OBJECT_TYPE)
      {
        m_gameObjectID = cast<GameObjectID>(value.AsObject());
        m_gameObjectLocName = value.AsString();
      }

      // This is used for the behaviour list support but is otherwise a legacy
      // codepath and should be avoided.
      if (value.GetType() == PropertyValue.INDEX_TYPE)
      {
        m_gameObjectName = value.AsString();
        m_gameObjectLocName = m_gameObjectName;
      }
    }

    // Legacy support to allow list selection of a different object type. Should be avoided.
    if (propertyIDLocal == "gameObjectType" and value.GetType() == PropertyValue.INDEX_TYPE)
    {
      m_gameObjectType = value.AsString();
      return;
    }


    inherited(propertyID, value);
  }


  //=============================================================================
  // Name: GetPropertyElementListObsolete
  // Desc: Obsolete - Do not call.
  //=============================================================================
  public obsolete string[] ObsoleteGetItemList()
  {
    // All of these usages are obsolete and will only return those objects that
    // are currently loaded.
    Interface.WarnObsolete("(EnumeratedGameObjectHandler) Legacy codepath, returned '" + m_gameObjectType + "' list may be incomplete");

    int i;
    string[] retStrList = new string[0];

    if (m_gameObjectType == "industry")
    {
      GameObject[] industries = World.GetIndustryList();
      for (i = 0; i < industries.size(); i++)
        retStrList[i] = industries[i].GetName();
    }
    else if (m_gameObjectType == "junction")
    {
      Junction[] junctions = World.GetJunctionList();
      for (i = 0; i < junctions.size(); i++)
        retStrList[i] = junctions[i].GetName();
    } 
    else if (m_gameObjectType == "signal")
    {
      Signal[] signals = World.GetSignalList();
      for (i = 0; i < signals.size(); i++)
        retStrList[i] = signals[i].GetName();
    }
    else if (m_gameObjectType == "trackmark")
    {
      TrackMark[] trackMarks = World.GetTrackMarkList();
      for (i = 0; i < trackMarks.size(); i++)
        retStrList[i] = trackMarks[i].GetName();
    }
    else if (m_gameObjectType == "traincar" or m_gameObjectType == "vehicle")
    {
      Vehicle[] vehicles = World.GetVehicleList();
      for (i = 0; i < vehicles.size(); i++)
        retStrList[i] = vehicles[i].GetName();
    }
    else if (m_gameObjectType == "trigger")
    {
      Trigger[] triggers = World.GetTriggerList();
      for (i = 0; i < triggers.size(); i++)
        retStrList[i] = triggers[i].GetName();
    }
    else if (m_gameObjectType == "cameratarget")
    {
      MapObject[] cameraTargets = World.GetCameraTargetList();
      for (i = 0; i < cameraTargets.size(); i++)
        retStrList[i] = cameraTargets[i].GetName();
    }

    return retStrList;
  }


  //=============================================================================
  // Name: GetPropertyElementList
  // Desc: Returns an list of possible options for the given property type.
  //=============================================================================
  public legacy_compatibility string[] GetPropertyElementList(string propertyID)
  {
    string propertyIDLocal = PropStripPrefix(propertyID, "");
    if (propertyIDLocal == "gameObjectName")
    {
      if (m_gameObjectType == "behavior")
      {
        string[] retStrList = new string[0];

        int i;
        ScenarioBehavior[] behaviors = World.GetBehaviors();
        for (i = 0; i < behaviors.size(); i++)
          retStrList[i] = behaviors[i].GetName();

        return retStrList;
      }

      return ObsoleteGetItemList();
    }

    return inherited(propertyID);
  }


  //=============================================================================
  // Name: SetCategoryCodeForType
  // Desc: Legacy support to update the old style type string to an appropriate
  //       category code, so that the async search functions can be used.
  //=============================================================================
  void SetCategoryCodeForType()
  {
    if (m_gameObjectType == "industry")
      m_gameObjectCategory = "IND";
    else if (m_gameObjectType == "traincar" or m_gameObjectType == "vehicle")
      m_gameObjectCategory = "TR";
    else if (m_gameObjectType == "signal")
      m_gameObjectCategory = "?WA";
    else if (m_gameObjectType == "junction")
      m_gameObjectCategory = "?WX";
    else if (m_gameObjectType == "trackmark")
      m_gameObjectCategory = "?WM";
    else if (m_gameObjectType == "trigger")
      m_gameObjectCategory = "?WT";
    else if (m_gameObjectType == "cameratarget")
      m_gameObjectCategory = "TR|?WA|?WX|BDB";
  }


  //=============================================================================
  // Name: GetProperties
  // Desc: Return properties of this object in a soup
  //=============================================================================
  public Soup GetProperties()
  {
    Soup soup = inherited();

    // Legacy support only. These two may be removed at some point.
    soup.SetNamedTag("EnumeratedGameObjectHandler.gameObjectName", m_gameObjectName);
    soup.SetNamedTag("EnumeratedGameObjectHandler.gameObjectType", m_gameObjectType);

    soup.SetNamedTag("EnumeratedGameObjectHandler.gameObjectID", m_gameObjectID);
    soup.SetNamedTag("EnumeratedGameObjectHandler.localisedName", m_gameObjectLocName);

    return soup;
  }


  //=============================================================================
  // Name: SetProperties
  // Desc: Initialize this object from the given properties soup
  //=============================================================================
  public void SetProperties(Soup soup)
  {
    inherited(soup);

    // Legacy support only. These two may be removed at some point.
    m_gameObjectName = soup.GetNamedTag("EnumeratedGameObjectHandler.gameObjectName");
    if (!m_gameObjectType.size())
      m_gameObjectType = soup.GetNamedTag("EnumeratedGameObjectHandler.gameObjectType");

    m_gameObjectID = soup.GetNamedTagAsGameObjectID("EnumeratedGameObjectHandler.gameObjectID");
    m_gameObjectLocName = soup.GetNamedTag("EnumeratedGameObjectHandler.localisedName");

    // Attempt to auto-update to a category code from the old config type
    if (m_gameObjectType != "" and m_gameObjectCategory == "")
      SetCategoryCodeForType();

    // Attempt to auto-update the display name (won't be localised, but good enough)
    if (m_gameObjectName != "" and m_gameObjectLocName == "")
      m_gameObjectLocName = m_gameObjectName;
  }

};



//! A generic editable add/remove list handler where list items are sub-handlers in this grouping.
//
// This class is a config handler class that allows a list handler where child handlers are list items
// to be constructed.  GenericListHandler does not work on its own and must be inherited from.  This is
// a complex and tricky class to use, so be careful and read the implementation to understand what is 
// going on.
//
// The config string table items this class supports are:
//
// {[ String Name                    | Description                                                             ]
//  [ "<config-prefix>-description"  | Text placed above the table to describe things. Optional if you don't
//                                     want titles/text stuff above your list.                                 ]
//  [  |  ]
//  [ "<config-prefix>-add"          | Text used in link to add an item to the list.  ]
//  [ "<config-prefix>-name-add"     | Name of list to select items from.             ]
//  [ "<config-prefix>-desc-add"     |  Description (tooltip) for list where items are selected from.  ]
//  [  |  ]
//  [ "<config-prefix>-add-all"      |  Description text for the link that adds all possible items to the list.
//                                     If this string entry is empty or not provided, then there will be no 
//                                     link to add everything - keep in mind that not all lists would even be
//                                     suited for this, so use with caution.                                   ]
//  [ "<config-prefix>-delete-all"   |  Description text for the link that deletes all list items.  If this 
//                                     string entry is empty or not provided, there will be no delete all
//                                     link provided (which in many cases is probably not a bad idea).         ]
//  [ "<config-prefix>-delete"       | Text used for the delete link next to each list item.                   ]
//  [  |  ]
//  [ "<config-prefix>-column0"      | Title of 1st column of the list.                                        ]
//  [ "<config-prefix>-columnX"      | Title of Xth column of the list.  How many of these column entries
//                                     there are dictates how many columns wide the list table is.  Numbering 
//                                     must be linear and sequential starting from 0.                          ]
//  [  |  ]
//  [ "<config-prefix>-html-prefix"  | HTML code inserted at the start of the properties page.  ]
//  [ "<config-prefix>-html-sufix"   | HTML code inserted at the end of the properties page.    ]}
//
// As will as the string table requirements, you must also override the <b ConstructHandlers()> method in your
// own child class.  <b ConstructHandlers()> is called by SetProperties() to re-create the child handlers (list
// items in this handler) before it will initialize them.
//
// The GenericListHandler class is used by the <l astSrcRuleSetJuncs  Set Junctions> rule with a config
// prefix of <m "set-junctions"> as shown in the table below:
//
// {[ String Name                          | Contents                                         ]
//  [ "set-junctions-display-name"         | "Set the following junctions to a specific state:&lt;br&gt;"  ]
//  [ "set-junctions-html-prefix"          | "&lt;table border='0' cellspacing='0' cellpadding='0'&gt;&lt;tr height=1&gt;&lt;td colspan=2&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td width=4&gt;&lt;/td&gt;&lt;td&gt;&lt;font color=#000000&gt;"  ]
//  [ "set-junctions-html-sufix"           | "&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;br&gt;&lt;br&gt;"  ]
//  [ "set-junctions-html-table-row-odd"   | "bgcolor=#CCCCAA22"                              ]
//  [ "set-junctions-html-table-row-even"  | "bgcolor=#CCCCAA44"                              ]
//  [ "set-junctions-html-property"        | "$0"                                             ]
//  [ "set-junctions-blank-string"         | "&lt;i&gt;click to select&lt;/i&gt;"             ]
//  [  |  ]
//  [ "set-junctions-add"                  | "Add Junction"                                   ]
//  [ "set-junctions-name-add"             | "Junctions"                                      ]
//  [ "set-junctions-desc-add"             | "Junction to add to the list"                    ]
//  [  |  ]
//  [ "set-junctions-add-all"              | "Add All"                                        ]
//  [ "set-junctions-add-all-tooltip"      | "Adds all junctions on the map to the list"      ]
//  [  |  ]
//  [ "set-junctions-delete-all"           | "Delete All"                                     ]
//  [ "set-junctions-delete-all-tooltip"   | "Deletes all junction from the list"             ]
//  [  |  ]
//  [ "set-junctions-column0"              | "&lt;font color=#000000&gt;&lt;i&gt;Junction&lt;/i&gt;&lt;/font&gt;&nbsp;&nbsp;"  ]
//  [ "set-junctions-column1"              | "&lt;font color=#000000&gt;&lt;i&gt;Setting&lt;/i&gt;&lt;/font&gt;&nbsp;&nbsp;"  ]
//  [ "set-junctions-column2"              | "&lt;font color=#000000&gt;&lt;i&gt;Locked&lt;/i&gt;&lt;/font&gt;&nbsp;&nbsp;"  ]
//  [ "set-junctions-delete"               | "&lt;font color=#000000&gt;Remove&lt;/font&gt;"  ]}
//
// Note that <l astSrcRuleSetJuncs  Set Junctions> has its own GenericListHandler-derived (<b JunctionListHandler>)
// class as will as a handler class (<b JunctionListItem>) that is used for junction list items.  You will 
// need to define an item handler to go with your GenericListHandler-derived class so the <m "&lt;\td&gt;&lt;td&gt;">
// tags can be inserted between table cells.
//
// This list handler class is used by the following rules:
//  - <l astSrcRuleDispHTMLPages   Display HTML Pages>
//  - <l astSrcRuleDrivCmdChk      Driver Command Check>
//  - <l astSrcRuleMultJuncCheck   Multiple Junction Alignment Check>
//  - <l astSrcRuleMultResrcCheck  Multiple Resource Check>
//  - <l astSrcRuleSetCoupMasks    Set Coupler Masks>
//
// Useful interface methods provided with this class are:
//  - public void                 <b AddItem>            (string itemDisplayName)
//  - public void                 <b RemoveItem>         (string itemName)
//  - public HTMLPropertyHandler  <b GetItem>            (int index)
//  - public int                  <b CountHandlers>      ()
//  - public int                  <b CountItems>         ()
//  - void                        <b ConstructHandlers>  (Soup listItemsSoup)
//
// Note:
//     GenericListHandler was mainly written as a utility class for use in the TRS2006 session rules.  It is
//     not part of the core %Trainz API and is not fully documented.  Those who are interested in how this 
//     class works can see all the full implementation in the <b \Trainz\scripts\ListItemPropertyHandler.gs>
//     script file.
//
// See Also:
//     AssetCheckListHandler, CheckListPropertyHandler, RadioButtonListHandler, RadioButtonGroupHandler,
//     EnumeratedPropertyHandler, EnumeratedGameObjectHandler, GenericBoolHandler, GenericStringHandler
//
class GenericListHandler isclass ConfigAssetGroupHandler
{
  // Titles for table colums of list items. The size of this string array dictates the amount of columns.
  string[] m_tableTitles = new string[0];
  string m_addLink = "";

  string m_displayName = "";

  string m_addAll = "";
  string m_addAllToolTip = "";
  string m_deleteAll = "";
  string m_deleteAllToolTip = "";

//  string m_htmlTableParams = "";
  string m_htmlTableRowEven = "";
  string m_htmlTableRowOdd = "";


  //
  // List Handler specific methods (ie not part of HTMLPropertyHandler/HTMLPropertyGroup)
  //

  public void Init(Asset asset, string newConfigPrefix);

  //@ Adds the named list item.  Is not to be directly called unless - doens't add the handler.
  //
  // Param:  itemDisplayName  ??
  //
  public void AddItem(string itemDisplayName);

  //@ Removes the named sub-handler list item.
  //
  // Param:  itemName  ??
  //
  public void RemoveItem(string itemName);

  //@ Gets the named sub=-handler list item.
  //
  // Param:  index  ??
  //
  // Returns:
  //     ??
  //
  public HTMLPropertyHandler GetItem(int index);

  //@ Gets the amount of sub handler list items in this list handler.
  //
  // Returns:
  //     ??
  //
  public int CountHandlers(void) { return handlers.size(); }

  //@ Re-creates the sub-handlers. Called by SetProperties(). Must be implemented in a child class.
  //
  // Param:  listItemsSoup  ??
  //
  void ConstructHandlers(Soup listItemsSoup);


  //
  // Initialization method. Must be used!
  //
  // Note: newConfigPrefix is not to be confused with the prefix!
  //
  public void Init(Asset asset, string newConfigPrefix)
  {
    inherited(asset, newConfigPrefix);

    // setup the table names
    int i = 0;
    while(true)
    {
      string newColumn = m_assetStrTable.GetString(m_configPrefix + "-column" + (string)i);
      if (newColumn  and  newColumn.size())
        m_tableTitles[i++] = newColumn;
      else
        break;
    }

    // add link
    m_addLink = m_assetStrTable.GetString(m_configPrefix + "-add");
    
    // display name (optional but warn if not present)
    m_displayName = m_assetStrTable.GetString(m_configPrefix + "-display-name");
    if (!m_displayName.size())
      Interface.Log("# GenericListHandler.Init> WARNING: Display name not found in host config asset: " + m_hostAsset.GetLocalisedName());

    // add all + delete all link text (options, doesn't matter if it isn't included
    m_addAll = m_assetStrTable.GetString(m_configPrefix + "-add-all");
    if (m_addAll.size()) 
      m_addAllToolTip = m_assetStrTable.GetString(m_configPrefix + "-add-all-tooltip");

    m_deleteAll = m_assetStrTable.GetString(m_configPrefix + "-delete-all");
    if (m_deleteAll.size())
      m_deleteAllToolTip = m_assetStrTable.GetString(m_configPrefix + "-delete-all-tooltip");

    // table cell stuff like colour etc. hard coded for now (maybe optional config file strings?)
    m_htmlTableRowEven = m_assetStrTable.GetString(m_configPrefix + "-html-table-row-even");
    m_htmlTableRowOdd  = m_assetStrTable.GetString(m_configPrefix + "-html-table-row-odd");
  }


  //
  // Adds a new item to the list.  Method well create appropriate sub-handler for it.
  //
  public void AddItem(string itemDisplayName)
  {
// dw: make this a blank implementation so the user HAS to implement it?
    HTMLPropertyHandler newItem = new HTMLPropertyHandler();

    // use a prefix derived from the itemDisplayName where any spaces are replaced with '-'
    string itemPrefix = TrainUtil.StrSubst(itemDisplayName, " ", "-");

    me.AddHandler(newItem, itemPrefix);
  }

  //
  // Remove the named item by name.  If the item can be found, it is returned, null otherwise.
  //
  public void RemoveItem(string itemName)
  {
    HTMLPropertyHandler handler = FindHandler(GetPrefix() + itemName);
    if (handler)
      RemoveHandler(handler);
  }

  public HTMLPropertyHandler GetItem(int index)
  {
    if ((index < handlers.size())  and  (index >= 0)) // dw: overly paranoid, maybe
      if (handlers[index])
        return handlers[index];

    return null;
  }

  //@ Gets the amount of sub handler list items in this list handler.
  public int CountItems(void) { return handlers.size(); }


  //
  // Property methods
  //

  public string[] GetPropertyElementList(string propertyID);

  //
  // Gets HTML page describing this object
  //
  public string GetDescriptionHTML(void)
  {
    // start the page with heading and open the table
    string htmlPage = "";

    htmlPage = htmlPage + m_displayName + "<br><table cellpadding=2 cellspacing=0><tr><td bgcolor=#00000022>"
                        + "<table cellspacing=1 cellpadding=2 bordercolor=#00000000 border=0><tr bgcolor=#00000011>";

    // generate top row of table column titles
    int i;
    for (i = 0; i < m_tableTitles.size(); i++)
      htmlPage = htmlPage + "<td bgcolor=#00000011>" + m_tableTitles[i] + "</td>";

    // delete column (in addition to our stuff)
    htmlPage = htmlPage + "<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr><tr height=2></tr>";

    // Do the table rows.  Each sub-handler in this group handler is considered to be a table row and it's
    // expected that each one returns a HTML table row that fits in with the requirements of this group list
    // handler's table.
    for (i = 0; i < handlers.size(); i++)
    {
      string tableOpen = m_htmlTableRowEven;

      if ((i % 2) == 0)
        tableOpen = m_htmlTableRowOdd;

      string itemToDelete = me.PropStripPrefix(handlers[i].GetPrefix(), "");

      htmlPage = htmlPage + "<tr " + tableOpen + ">" + handlers[i].GetDescriptionHTML() +
                 "<td>" + HREF("delete/" + itemToDelete) + 
                 m_assetStrTable.GetString(m_configPrefix + "-delete") + "</a>&nbsp;&nbsp;</td></tr>";

      if (i < (handlers.size()-1))
        htmlPage = htmlPage + "<tr height=2></tr>";
    }

    // close off the table
    htmlPage = htmlPage + "</table></td></tr></table><br>";

    // add link that sits just below table
    htmlPage = htmlPage + HREF("add") + m_addLink + "</a>";

    // put in the 'add all' and 'delete all' links if the host config allows for it
    if (m_addAll.size())
      htmlPage = htmlPage + "<br>" + HREF("add-all' tooltip='" + m_addAllToolTip) + m_addAll + "</a>";

    if (m_deleteAll.size())
      htmlPage = htmlPage + "<br>" + HREF("delete-all' tooltip='" + m_deleteAllToolTip) + m_deleteAll + "</a>";

//Interface.Log("## List Item Handler: '" + m_htmlPrefix + htmlPage + m_htmlSufix + "'");
    return m_htmlPrefix + htmlPage + m_htmlSufix;
  }

  //
  // Gets type for named property.
  //
  public string GetPropertyType(string propertyID)
  {
    string property = PropStripPrefix(propertyID, "");

    if (property == "add")
      return "list,1";

    if ((property == "add-all") or (property == "delete-all"))
      return "link";

    if (TrainUtil.GetUpTo(property, "/") == "delete")
      return "link";

    return inherited(propertyID);
  }

  //
  // Sets value of named property.
  //
  public void SetPropertyValue(string propertyID, PropertyValue value)
  {
    string property = PropStripPrefix(propertyID, "");

    if (property == "add")
      AddItem(value.AsString());

    // the default 'add-all' simply adds all items from whatever GetPropertyElementList() returns
    // you might want to process this different in your own child method (ie the list of items
    // is based on what you select from the add list)
    else if (property == "add-all")
    {
      string[] items = me.GetPropertyElementList(Prop("add")); // use list for add to find all items
      int i;
      for (i = 0; i < items.size(); i++)
        AddItem(items[i]);
    }
    else if (property == "delete-all")
    {
      Interface.Log("# GenericListHandler.SetPropertyValue> INFO: Deleting entire list..");
      handlers = new HTMLPropertyHandler[0];
    }
    else if (TrainUtil.GetUpTo(property, "/") == "delete")
      RemoveItem(PropStripPrefix(propertyID, "delete/") );

    else
      inherited(propertyID, value);
  }

  //
  // Gets list of elements to choose from for the named property
  //
  public string[] GetPropertyElementList(string propertyID)
  {
    if (PropStripPrefix(propertyID, "") == "add")
    {
      Interface.Log("# GenericListHandler.GetPropertyElementList> NOTE: You must implement me, I can't predict what items you want listed!");
      string[] retStrList = new string[0];
      return retStrList;
    }

    return inherited(propertyID);
  }

  public string GetPropertyName(string propertyID)
  {
    string property = PropStripPrefix(propertyID, "");
    if (property == "add")
      return m_assetStrTable.GetString(m_configPrefix + "-name-" + property);

    return inherited(propertyID);  
  }

  public string GetPropertyDescription(string propertyID)
  {
    string property = PropStripPrefix(propertyID, "");
    if (property == "add")
      return m_assetStrTable.GetString(m_configPrefix + "-desc-" + property);

    return inherited(propertyID);  
  }

  //
  // Gets this list as a soup.
  //
  public Soup GetProperties()
  {
    Soup soup = inherited();

    int i;

    /* table titles array
    Soup tableTitlesSoup = Constructors.NewSoup();
    for (i = 0; i < m_tableTitles.size(); i++)
      tableTitlesSoup.SetNamedTag((string)i, m_tableTitles[i]);
    soup.SetNamedSoup("GenericListHandler.tableTitles", tableTitlesSoup);*/

    // handler list items - simply grab properties from each item and put them into a list items sub-soup.
    Soup listItemsSoup = Constructors.NewSoup();
    for (i = 0; i < handlers.size(); i++)
    {
      string strippedPrefix = PropStripPrefix(handlers[i].GetPrefix(), "");
      listItemsSoup.SetNamedSoup(strippedPrefix, handlers[i].GetProperties());
    }
    soup.SetNamedSoup("GenericListHandler.listItems", listItemsSoup);

    return soup;
  }

  public void SetProperties(Soup soup)
  {
    // Careful, HTMLPropertyGroup.SetProperties() will initialize handler's with soups if their
    // GetSaveProperties() flag is enabled! But that's ok if handlers array is empty
    inherited(soup);

    handlers = new HTMLPropertyHandler[0]; // reset list when re-creating

    /* table titles array
    Soup tableTitlesSoup = soup.GetNamedSoup("GenericListHandler.tableTitles");
    m_tableTitles = new string[0];
    int i;
    for (i = 0; i < tableTitlesSoup.CountTags(); i++)
      m_tableTitles[i] = tableTitlesSoup.GetNamedTag((string)i);*/

    // for the list items (handlers), we assume that the user's ConstructHandlers()
    // implementation can successfully do that
    ConstructHandlers(soup.GetNamedSoup("GenericListHandler.listItems"));
  }


  void ConstructHandlers(Soup listItemsSoup)
  {
    Interface.Log("# GenericListHandler.ConstructHandlers> NOTE: Someone forgot to implement me - anyway, some soup list item facts are...");
    int i;
    for (i = 0; i < listItemsSoup.CountTags(); i++)
      Interface.Log("#                                     >  - " + i + " '" + listItemsSoup.GetIndexedTagName(i) + "'");
  }

};



// ============================================================================
// Name: GenericTimeHandler
// Desc: Property Handler assistant for a time-of-day value
// ============================================================================
class GenericTimeHandler isclass ConfigAssetHandler
{
  int m_hours   = 0; // 0..24
  int m_minutes = 0; // 0..59
  int m_seconds = 0; // 0..59
 

  // ==========================================================================
  // Name: GetHours
  // Retn: The current hours element value
  // Desc: Returns the current hours element value
  // ==========================================================================
  public int GetHours(void) { return m_hours; }


  // ==========================================================================
  // Name: GetMinutes
  // Retn: The current minutes element value
  // Desc: Returns the current minutes element value
  // ==========================================================================
  public int GetMinutes(void) { return m_minutes; }


  // ==========================================================================
  // Name: GetSeconds
  // Retn: The current seconds element value
  // Desc: Returns the current seconds element value
  // ==========================================================================
  public int GetSeconds(void) { return m_seconds; }


  // ==========================================================================
  // Name: GetTimeOfDay
  // Retn: A Trainz compatible time-of-day float
  // Desc: Trainz time of day float is in the range 0..1 from midday to midday
  // ==========================================================================
  public float GetTimeOfDay(void)
  {
    // game time is in the range 0..1 (midday to midday), but conventional HH:mm:ss is midnight to midnight.
    
    // Start the calculation at midnight the previous "trainz day"
    float time = -0.5f;
    
    time = time + m_hours  /24; // 24 hours per day
    time = time + m_minutes/1440; // 24*60 (1440) minutes per day
    time = time + m_seconds/86400; // 24*60*60 (86400) seconds per day
    
    // negative values (i.e. haven't reached midday yet) need to be pushed around to the next day
    // so we keep within the 0..1 range
    if (time < 0)
    {
      time = time + 1.0f;
    }
    
    return time;
  }


  // ==========================================================================
  // Name: SetHours
  // Parm: newHours - A new hours value
  // Desc: Sets the hours element of the time
  // ==========================================================================
  public void SetHours(int newHours)
  {
    if (newHours >= 0 and newHours < 24)
    {
      m_hours = newHours;
    }
    else
    {
      m_hours = 0;
    }
  }


  // ==========================================================================
  // Name: SetMinutes
  // Parm: newMinutes - A new minutes value
  // Desc: Sets the minutes element of the time
  // ==========================================================================
  public void SetMinutes(int newMinutes)
  {
    if (newMinutes >= 0 and newMinutes < 60)
    {
      m_minutes = newMinutes;
    }
    else
    {
      m_minutes = 0;
    }
  }


  // ==========================================================================
  // Name: SetSeconds
  // Parm: newSeconds - A new seconds value
  // Desc: Sets the seconds element of the time
  // ==========================================================================
  public void SetSeconds(int newSeconds)
  {
    if (newSeconds >= 0 and newSeconds < 60)
    {
      m_seconds = newSeconds;
    }
    else
    {
      m_seconds = 0;
    }
  }


  // ==========================================================================
  // Name: Init
  // Parm: asset - the asset using this handler
  // Parm: newConfigPrefix - the config prefix string
  // Desc: crude but necessary work-around copied from previous handlers
  // ==========================================================================
  public void Init(Asset asset, string newConfigPrefix)
  { 
    inherited(asset, newConfigPrefix); 
  }


  // ==========================================================================
  // Name: Init
  // Parm: asset - the asset using this handler
  // Parm: newConfigPrefix - the config prefix string
  // Parm: defaultHours - the initial value for the 'hours' element
  // Parm: defaultMinutes - the initial value for the 'hours' element
  // Parm: defaultSeconds - the initial value for the 'hours' element
  // Desc: crude but necessary work-around copied from previous handlers
  // ==========================================================================
  public void Init(Asset asset, string newConfigPrefix, int defaultHours, int defaultMinutes, int defaultSeconds)
  { 
    Init(asset, newConfigPrefix); 

    m_hours = defaultHours;
    m_minutes = defaultMinutes;
    m_seconds = defaultSeconds;
  }

  
  // ==========================================================================
  // Name: TwoDigits
  // Parm: number - the number to format
  // Retn: string form of number (minimum of two digits)
  // Desc: Packs a string with leading zeros if necessary
  // ==========================================================================
  string TwoDigits(int number)
  {
    string retval = "" + number;
    
    if (retval.size() < 2)
    {
      retval = "0" + retval;
    }
    return retval;
  }


  // ==========================================================================
  // Name: GetDisplayTime
  // Retn: HH:mm:ss format string of the time
  // Desc: Converts the time into HH:mm:ss format for human display
  //       Requires a config entry of the form:
  //       <config-prefix>-html-property-timemask         "$0:$1:$2"
  // ==========================================================================
  public string GetDisplayTime(void)
  {
    return m_assetStrTable.GetString3(m_configPrefix + "-html-property-timemask", TwoDigits(GetHours()), TwoDigits(GetMinutes()), TwoDigits(GetSeconds()));
  }


  // ==========================================================================
  // Name: GetDescriptionHTML
  // Retn: HTML containing clickable HH:mm:ss format string of the time
  // Desc: Converts the time into HH:mm:ss format for human display. Adds links
  //       so the user can adjust individual parts of the time.
  //       Requires a config entry of the form:
  //       <config-prefix>-html-property-timemask         "$0:$1:$2"
  // ==========================================================================
  public string GetDescriptionHTML(void)
  {
    string hoursLink = "<a href='" + Link("hoursValue") + "'>" + TwoDigits(GetHours()) + "</a>";
    string minutesLink = "<a href='" + Link("minutesValue") + "'>" + TwoDigits(GetMinutes()) + "</a>";
    string secondsLink = "<a href='" + Link("secondsValue") + "'>" + TwoDigits(GetSeconds()) + "</a>";
    
    string htmlPage = m_assetStrTable.GetString3(m_configPrefix + "-html-property-timemask", hoursLink, minutesLink, secondsLink);
    return m_htmlPrefix + htmlPage + m_htmlSufix;
  }


  // ==========================================================================
  // Name: GetPropertyType
  // Retn: string property type code
  // Desc: Gets type for named property.
  // ==========================================================================
  public string GetPropertyType(string p_propertyID)
  {
    if (PropStripPrefix(p_propertyID, "") == "hoursValue")
      return "int,0,23,1";
    if (PropStripPrefix(p_propertyID, "") == "minutesValue")
      return "int,0,59,1";
    if (PropStripPrefix(p_propertyID, "") == "secondsValue")
      return "int,0,59,1";

    return inherited(p_propertyID);
  }


  // ==========================================================================
  // Name: GetPropertyName
  // Retn: string property display name
  // Desc: Gets display name for named property.
  // ==========================================================================
  public string GetPropertyName(string p_propertyID)
  {
    if (PropStripPrefix(p_propertyID, "") == "hoursValue")
      return m_assetStrTable.GetString(m_configPrefix + "-hours-name");
    if (PropStripPrefix(p_propertyID, "") == "minutesValue")
      return m_assetStrTable.GetString(m_configPrefix + "-minutes-name");
    if (PropStripPrefix(p_propertyID, "") == "secondsValue")
      return m_assetStrTable.GetString(m_configPrefix + "-seconds-name");

    return inherited(p_propertyID);
  }


  // ==========================================================================
  // Name: GetPropertyDescription
  // Retn: string property description
  // Desc: Gets description for named property.
  // ==========================================================================
  public string GetPropertyDescription(string p_propertyID)
  {
    if (PropStripPrefix(p_propertyID, "") == "hoursValue")
      return m_assetStrTable.GetString(m_configPrefix + "-hours-desc");
    if (PropStripPrefix(p_propertyID, "") == "minutesValue")
      return m_assetStrTable.GetString(m_configPrefix + "-minutes-desc");
    if (PropStripPrefix(p_propertyID, "") == "secondsValue")
      return m_assetStrTable.GetString(m_configPrefix + "-seconds-desc");

    return inherited(p_propertyID);
  }


  // ==========================================================================
  // Name: SetPropertyValue
  // Parm: p_propertyID - property ID
  // Parm: p_value - new property value
  // Desc: Sets value of named property
  // ==========================================================================
  public void SetPropertyValue(string p_propertyID, int p_value)
  {
    if (PropStripPrefix(p_propertyID, "") == "hoursValue")
      SetHours(p_value);
    else if (PropStripPrefix(p_propertyID, "") == "minutesValue")
      SetMinutes(p_value);
    else if (PropStripPrefix(p_propertyID, "") == "secondsValue")
      SetSeconds(p_value);
    else
      inherited(p_propertyID, p_value);
  }

  public void SetPropertyValue(string p_propertyID, PropertyValue p_value)
  {
    if (PropStripPrefix(p_propertyID, "") == "hoursValue")
      SetHours(p_value.AsInt());
    else if (PropStripPrefix(p_propertyID, "") == "minutesValue")
      SetMinutes(p_value.AsInt());
    else if (PropStripPrefix(p_propertyID, "") == "secondsValue")
      SetSeconds(p_value.AsInt());
    else
      inherited(p_propertyID, p_value);

    }



  // ==========================================================================
  // Name: GetProperties
  // Retn: soup of all property values
  // Desc: Return properties of this object in a soup
  // ==========================================================================
  public Soup GetProperties()
  {
    Soup soup = inherited();
    soup.SetNamedTag("GenericTimeHandler.hours"  , m_hours  );
    soup.SetNamedTag("GenericTimeHandler.minutes", m_minutes);
    soup.SetNamedTag("GenericTimeHandler.seconds", m_seconds);
    return soup;
  }


  // ==========================================================================
  // Name: SetProperties
  // Parm: soup with property values
  // Desc: Initialize this object from the given properties soup
  // ==========================================================================
  public void SetProperties(Soup soup)
  {
    inherited(soup);
    m_hours   = soup.GetNamedTagAsInt("GenericTimeHandler.hours"  , m_hours  );
    m_minutes = soup.GetNamedTagAsInt("GenericTimeHandler.minutes", m_minutes);
    m_seconds = soup.GetNamedTagAsInt("GenericTimeHandler.seconds", m_seconds);
  }
};


